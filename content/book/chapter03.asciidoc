---
title: "Chapter 3: CFEngine Basics"
date: 2017-10-24T19:41:06+02:00
menu: book
weight: 3
---
:toc: auto
:source-highlighter: pygments
:sourcedir: content/book/newsrc
:experimental:

[[ch-cfengine-basics]]
== CFEngine Basics

In this chapter we will take a more detailed look at the basic concepts behind CFEngine, including its theoretical foundation, the syntax and constructs of its policy language, and some unique aspects of its behavior. I will also point you to some of the many online resources available for learning and improving your CFEngine skills.

[[I_sect13_d1e1706]]
=== Basic Principles

One((("CFEngine", id="ch3-cfe", range="startofrange"))) of CFEngine’s unique characteristics is that it is built upon predefined, solid theoretical and behavioral principles. These principles guide the design and implementation of all the CFEngine components and of its policy language, and ensure that the behavior of those components remains consistent. These principles are: desired-state configuration, a minimum base set of native operations, promise theory, and convergent configuration. Let us look at them in more detail.

[[principles]]
==== Desired-State Configuration

CFEngine((("states of system, desired", id="ch3-des3", range="startofrange")))((("CFEngine", "desired-state configuration principle", id="ch3-des2", range="startofrange")))((("desired-state configuration", id="ch3-des", range="startofrange"))) is different from many other automation mechanisms in that you do not need to tell it what to do. Instead, you specify the state in which you wish the system to be, and CFEngine will automatically decide the actions to take to reach the desired state, or as close to it as possible. In programming language terms, we say that the CFEngine policy language is __declarative__, as opposed to __imperative__.

These((("states of system, desired", "declaring", see="policies"))) are some examples of the things that you can express to CFEngine as desired states:


* “Make sure file __/etc/ssh/sshd_config__ contains the line ++UseDNS no++”


* “Make sure user ++mysql++ exists/does not exist”


* “Make sure process ++httpd++ is (not) running”

At a higher level of abstraction, you can encapsulate CFEngine operations and express high-level desired states:


* “Make sure all web servers have Apache installed”


* “Make sure all ++root++ accounts have the same, centrally-designated password”


* “Make sure parameters ++UseDNS++ and ++PermitRootLogin++ are disabled on all ++sshd++ configurations, except on servers ++dbsrv01++ and ++dbsrv02++, where ++PermitRootLogin++ should be enabled”

And at an even higher level, you can express top-level desired states like these:


* “Configure host ++dbsrv01++ as a database server”


* “Create a new cluster of VMs to use as web servers”


* “Give me a new datacenter in EC2 region ++ap-northeast-1++”

Of course, in reality things are not so simple. At some point, CFEngine needs to know what specific changes to make to the system, and how to make (((range="endofrange", startref="ch3-des3")))(((range="endofrange", startref="ch3-des2")))(((range="endofrange", startref="ch3-des")))them.


==== Basic CFEngine Operations

These((("CFEngine", "operations supported by", id="ch3-ops", range="startofrange"))) are some of the basic operations that CFEngine natively knows how to perform:footnote:[This is by necessity an incomplete list—it reflects only the major features implemented by major promise types in CFEngine. There are many other operations implemented by functions or by CFEngine’s monitoring components that allow both querying and modifying the system. Plus CFEngine is constantly evolving, so by the time you read this, new features may have appeared.]


* Extract information from the system itself about its current state and configuration.


* Inspect and modify the contents of text and XML files.


* Check for and manipulate file permissions and ownerships.


* Check for existence of processes running in the system.


* Check for existence of users in the system.


* Run programs and check their exit status.


* Check and manipulate packages installed on the system.


* Check and manipulate services on Unix systems.


* Query and manipulate databases and their contents (as of this writing, MySQL, PostgreSQL and SQLite are supported).


* Examine and manipulate POSIX Access Control Lists (ACLs).


* Manipulate virtual machines on several different platforms (as of this writing, VMware ESX, KVM, Xen and VirtualBox are supported).

The ((("Commercial/Enterprise Edition", "operations supported by")))commercial version of CFEngine has some additional capabilities, including the following:


* Check and manipulate the Windows registry, event logs, and services.


* Query and manipulate LDAP (and, by extension, Active Directory) databases.


* Examine and manipulate Windows Access Control Lists (ACLs).

These operations are sufficient to perform most configuration tasks on a system. At the lowest possible level, CFEngine contains functional specifications of how to make changes to the system. At the highest level, however, you declare what you want as shown in <<principles>>, and leave the details to CFEngine.

CFEngine ships with some built-in libraries that perform more advanced operations using these basic capabilities, and you can also build your own libraries to perform custom checks and activities.

[[promise-theory]]
==== Promise Theory

CFEngine 3 ((("CFEngine", "Promise Theory used by", id="ch3-pt", range="startofrange")))((("Promise Theory", id="ch3-pt2", range="startofrange")))((("online resources", "Promise Theory")))works on top of a theoretical model called link:http://research.iu.hio.no/promises.php[Promise Theory]. This theory models the behavior of autonomous agents in an environment without central authority, based only on promises of behavior made by each agent, and shows that even without central control, the system can converge to a stable state.

Promise Theory((("voluntary cooperation"))) underlays one of the basic tenets of CFEngine: voluntary cooperation. In CFEngine, each system participates voluntarily, makes promises only about its own behavior (if you think about it, it makes no sense for a system to make promises about someone else’s behavior), and cannot be forced to accept commands or information from any external entities. This((("security", "voluntary cooperation enforcing"))) gives CFEngine very strong security properties, since it means that CFEngine running on a host cannot be coerced into modifying its behavior according to some external influence. It may __choose__ to do so (for example, by getting policies from a central server), but unlike many other configuration management systems, CFEngine does not require you to open a command channel through which each host can be given instructions (all you can do is “ping” clients so that they run their policies before their scheduled time, or to query them for information, but never to perform arbitrary actions or commands).


[NOTE]
====
It’s ((("security", "published vulnerabilities of CFEngine")))worth mentioning that CFEngine’s principle of voluntary cooperation is more than a theoretical nicety in terms of security: in its entire 20-year history (spanning versions 1 through 3), CFEngine has had only link:http://web.nvd.nist.gov/view/vuln/search-results?query=cfengine[six published vulnerabilities], only three of which were remotely exploitable. The last one of those was published in 2005, still in CFEngine 2. CFEngine 3 has the impressive record of zero published vulnerabilities since its release in 2009.

====

A ((("declaration of intent", see="Promise Theory")))((("intent, declaration of", see="Promise Theory")))((("promises")))((("promisers")))promise is simply a declaration of __intent__, a model of the desired state of the promiser. A promise does not imply that the desired state will be reached in the next iteration (or ever), but implies a capability for verifying whether the promise has been satisfied. Through this seemingly simple characteristic, promise theory allows CFEngine to deal with a crucial aspect of systems management: operational uncertainty. Systems are under constant change, both intentional (changing requirements, changing software, changing user behavior, security attacks) and accidental (disconnected network links, disappearing resources, software crashes) and have to react to it, often with incomplete information. Promise theory allows CFEngine to deal with these conditions in a resilient fashion.

Promise Theory was developed initially as the foundation for CFEngine’s behavior (in fact, the policy language in CFEngine 3 was redesigned to reflect this theory), but it has found more general applications in Computer Science and in other disciplines such as Economics and Organization.

According to Promise Theory, everything in CFEngine 3 is a promise, with specifications of what to do if the promise is already satisfied, if the promise was not satisfied but could be fixed, if the promise was not satisfied and could not be fixed, etc. <<tab-promise-examples>> shows((("promisers", "examples of")))((("promises", "examples of"))) some examples of promises you could find in a CFEngine policy, and of the possible actions CFEngine could take automatically if the promise is not kept.

[[tab-promise-examples]]
.Examples of objects (promisers), promises, and repair actions in CFEngine
[options="header"]
|===============
|Promiser|Promises to…|If not currently kept, CFEngine will…
|A variable|…hold a certain value of a certain type.|…store the appropriate value in the variable.
|A file|…have certain characteristics (permissions, ownership, ACLs, etc.).|…set the desired properties on the file.
|A file|…exist and to have certain content.|…create the file if needed, modify its content (add, remove or edit lines) to match the desired state.
|A user account|…exist and have certain characteristics (home directory, group, etc.)|…create the user account with the desired characteristics.
|A process|…be running on the system.|…run the appropriate command to create the process.
|A shell command|…have been executed.|…execute the command and collect its output and exit status.
|A directory on the policy hub|…provide access to its content to certain clients.|…reconfigure its access rules to permit or block the access as desired.
|An output message|…be generated when certain conditions arise, with a certain frequency and in a certain format.|…produce the appropriate message.

|===============

When a promise is not already satisfied (e.g., a file does not exist as it should), CFEngine will take the necessary actions to fix it, according to both its built-in rules and any additional promises declared in the policy.

Depending((("states of promises")))((("promises", "states of"))) on the current state of the system with respect to a given promise, on the actions that CFEngine took when evaluating a promise, and on the result of those actions, CFEngine defines the following promise states:

Promise kept:: 
    The state of the system was already as described by the promise, so no action had to be taken.

Promise repaired:: 
    The state of the system was not as required by the promise, so CFEngine took the appropriate actions, and repaired the system state to match the requirements of the promise.

Repair failed:: 
    Repair actions were attempted by CFEngine, but they failed for some reason (for example, lack of permissions to edit a file). Depending on why the repair action failed, one of the following states may also be set:
 Repair denied;; 
    Repair actions were attempted by CFEngine, but they failed due to lack of access to some resource.
 Repair timeout;; 
    Repair actions were attempted by CFEngine but took too long to execute, and CFEngine cancelled the operation.



A CFEngine policy is constructed out of individual promises that get executed in certain order, and that can interact with other promises. After a promise is evaluated (executed), you can determine its state and act based on it, triggering further actions such as reporting, command execution, or evaluation of other (((range="endofrange", startref="ch3-pt2")))(((range="endofrange", startref="ch3-pt")))promises.

[[convergent-configuration]]
==== Convergent Configuration

One((("states of system, desired", "converging to", see="convergent configuration")))((("CFEngine", "convergent configuration used by")))((("convergent configuration"))) of CFEngine’s basic principles is convergent configuration. This means that you don’t have to leave the system in the desired state on the first pass. Instead, you make changes incrementally, getting closer to the objective every time, independently of the starting state of the system. A CFEngine policy may not leave the system completely configured on the first pass, but at least it will make some changes. On subsequent passes, it will continue to make changes, eventually bringing it as close as possible to the desired state.

One advantage of convergent configuration, and of the declarative nature of CFEngine, is that you do not need to know the current state of the system in order to correct it. If the system is already in the desired state, a correctly written CFEngine policy will do nothing. If it’s not, CFEngine will iteratively make discrete changes to bring it closer to the ideal, taking only the necessary actions to correct the existing deviations.

In((("policies", "three passes over"))) order to carry out convergent configuration, CFEngine performs three passes over its policy. During each pass, all the promises in the policy are evaluated. There may be some promises that cannot be evaluated until the second or third pass due to dependencies between different components of the policy, so the multiple passes help CFEngine bring things to a convergent state as soon as (((range="endofrange", startref="ch3-cfe")))possible.

[[sec-cfengine-components]]
=== CFEngine Components

A ((("CFEngine", "components of", id="ch3-comp", range="startofrange")))CFEngine installation contains multiple components that perform different, specific functions, as shown in <<cfengine-components>>. Dotted lines represent components that execute others, solid lines represent communication among components, and bold lines indicate data flow.

Let’s look in more detail at the functionality and role of each one of these components.

[[cfengine-components]]
.CFEngine components and their relationships
image::../figs/web/lcfe_0301.png[]

link:http://cf-learn.info/ref/cf-agent[ ++cf-agent++ ]:: 
    This((("cf-agent command"))) is the “instigator of change,” as described in the CFEngine documentation. link:http://cf-learn.info/ref/cf-agent[++cf-agent++] is the program that evaluates policies and acts on them, making any necessary changes to the system. link:http://cf-learn.info/ref/cf-agent[++cf-agent++] is normally started directly by the user (for example, we have been running it manually from the command line to test the policies in this book), or by one of two higher-level commands: link:http://cf-learn.info/ref/cf-execd[++cf-execd++] (as a mechanism for starting it at regular intervals) or link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] (in response to the link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] command executed from a different host). Note that depending on its policies, link:http://cf-learn.info/ref/cf-agent[++cf-agent++] can in turn be responsible for restarting link:http://cf-learn.info/ref/cf-execd[++cf-execd++], ++cf-serverd++ or link:http://cf-learn.info/ref/cf-monitord[++cf-monitord++] if they have stopped for any reason (in addition, link:http://cf-learn.info/ref/cf-promises[++cf-promises++] is used by link:http://cf-learn.info/ref/cf-agent[++cf-agent++] to validate its policies before attempting to run them).
+
By((("promises.cf file"))) default, link:http://cf-learn.info/ref/cf-agent[++cf-agent++] will attempt to run __/var/cfengine/inputs/promises.cf__ (more precisely, the file found by expanding the string ++$(sys.workdir)/inputs/promises.cf++) when invoked, unless a different file is specified using the ++-f++ command-line option. If ((("failsafe.cf file")))the filename executed produces an error, link:http://cf-learn.info/ref/cf-agent[++cf-agent++] will try to run __/var/cfengine/inputs/failsafe.cf__. The idea is for __failsafe.cf__ to be a barebones policy that does little more than try to restore the CFEngine policies to a working state. Normally __failsafe.cf__ will attempt to update the local policies from the policy hub, and it may also try to start link:http://cf-learn.info/ref/cf-execd[++cf-execd++] and link:http://cf-learn.info/ref/cf-monitord[++cf-monitord++] to have at least a minimal CFEngine infrastructure running. If the __failsafe.cf__ file is not found, link:http://cf-learn.info/ref/cf-agent[++cf-agent++] will generate it.


link:http://cf-learn.info/ref/cf-execd[ ++cf-execd++ ]:: 
    This ((("cf-execd process")))process executes link:http://cf-learn.info/ref/cf-agent[++cf-agent++] in a periodic basis, collecting its output, and potentially emailing it somewhere. By default, link:http://cf-learn.info/ref/cf-execd[++cf-execd++] runs link:http://cf-learn.info/ref/cf-agent[++cf-agent++] every five minutes, but ((("executor control body")))((("bodies", "executor control")))((("control bodies", "executor control")))you can modify its behavior using an ++executor control++ body. For example:
+
[source,cf3]
----
include::{sourcedir}/ch03_1.cf[]
----
+
In((("schedule attribute"))) this case, the link:http://cf-learn.info/ref/schedule[++schedule++] attribute tells link:http://cf-learn.info/ref/cf-execd[++cf-execd++] to only run link:http://cf-learn.info/ref/cf-agent[++cf-agent++] every 30 minutes (more precisely, whenever either the ++Min00_05++ or ++Min30_35++ classes are enabled, which would be the case between 00-05 and 30-35 minutes of every hour). The((("splaytime attribute"))) link:http://cf-learn.info/ref/splaytime[++splaytime++] parameter tells link:http://cf-learn.info/ref/cf-execd[++cf-execd++] that the execution could be delayed up to 10 minutes (this is useful in large installations to prevent all the clients from connecting to the server at once). The((("smtpserver attribute")))((("mailfrom attribute")))((("mailto attribute"))) link:http://cf-learn.info/ref/mailto[++mailto++], link:http://cf-learn.info/ref/mailfrom[++mailfrom++] and link:http://cf-learn.info/ref/smtpserver[++smtpserver++] attributes determine how email reports will be sent.
+
It is common for link:http://cf-learn.info/ref/cf-execd[++cf-execd++] to be the one process started by the operating system (for example, through a ++cron++ job or an ++init++ script) when the system starts. link:http://cf-learn.info/ref/cf-execd[++cf-execd++] then runs link:http://cf-learn.info/ref/cf-agent[++cf-agent++], which makes sure through the appropriate policies that link:http://cf-learn.info/ref/cf-execd[++cf-execd++], link:http://cf-learn.info/ref/cf-monitord[++cf-monitord++], and link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] are running in the background, if needed.


link:http://cf-learn.info/ref/cf-serverd[ ++cf-serverd++ ]:: 
    This ((("cf-serverd process")))component implements server functionality in CFEngine—the ability to listen for connections from clients and serve files to them. link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] also has the ability to listen for connections from the link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] process in other hosts, and according to its configuration, respond by executing link:http://cf-learn.info/ref/cf-agent[++cf-agent++] locally (this is the one reason why you may want to run link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] on CFEngine clients: if you want the policy hub to be able to remotely instruct clients to run link:http://cf-learn.info/ref/cf-agent[++cf-agent++]). We will look in more detail at the link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] configuration in <<clients-and-servers-2>>. link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] listens on port TCP/5308, and this is the only port that needs to be open for the clients to be able to communicate with the server.


link:http://cf-learn.info/ref/cf-runagent[ ++cf-runagent++ ]:: 
    Invokes((("cf-runagent command"))) link:http://cf-learn.info/ref/cf-agent[++cf-agent++] on remote hosts so that they evaluate their policies. This is the only form of control a remote machine may exercise over another in CFEngine. We will talk more about this in <<remote-execution-cfrunagent>>.


link:http://cf-learn.info/ref/cf-key[ ++cf-key++ ]:: 
    This((("cf-key command"))) is one of the first commands you run when installing CFEngine on a new host. It creates a cryptographic key pair for the current host, which is used for authentication when communicating with the policy hub or any other CFEngine server.


link:http://cf-learn.info/ref/cf-monitord[ ++cf-monitord++ ]:: 
    This((("cf-monitord process"))) process is intended to run continuously in the background. It collects statistical information about different aspects of the system and makes it available to link:http://cf-learn.info/ref/cf-agent[++cf-agent++] through the special++mon++ variable context. Some examples of the information collected by link:http://cf-learn.info/ref/cf-monitord[++cf-monitord++] are the numbers of users with active processes in the system (++mon.value_users++), free space in the root disk partition (++mon.value_diskfree++), and kernel load average (++mon.value_loadavg++). For most values link:http://cf-learn.info/ref/cf-monitord[++cf-monitord++] also keeps a running average and the standard deviation (for example, ++mon.av_loadvg++ and ++mon.dev_loadavg++).


link:http://cf-learn.info/ref/cf-hub[++cf-hub++]:: 
    This ((("cf-hub process")))process exists only in CFEngine Enterprise, and is responsible for collecting from all the clients information about their current status, reports and monitoring information, for analysis and reporting purposes. ++cf-hub++ periodically connects to the ++cf-serverd++ process on all the clients it knows about (this is, all the clients that have bootstrapped to it) to collect this information. If it cannot connect to a client, this information is also reported in the Enterprise (((range="endofrange", startref="ch3-comp")))console.


[[a-first-example]]
=== A First Example

Let’s ((("SSH (Secure Shell)", "configuring", "with policies", id="ch3-ex", range="startofrange")))consider the simple case of modifying the configuration of an ++ssh++ server. At the top level, we need to make sure the sshd service is up and running. With CFEngine, we can simply write the following:


[source,cf3]
----
services:
  "ssh";
----

This will by default enable and make sure the service is running, on any operating system. If we wanted to make sure the service is not running, we would simply need to write:


[source,cf3]
----
services:
  "ssh" service_policy => "stop";
----


[TIP]
====
A ((("promises", "services: type")))((("services: promises")))new model for link:http://cf-learn.info/ref/services[++services:++] promises was introduced in CFEngine 3.3.0, which allows greatly simplified service management as shown above. In previous versions, you needed to manipulate the services through a combination of link:http://cf-learn.info/ref/processes[++processes:++] and link:http://cf-learn.info/ref/commands[++commands:++] promises.

====

Now, let’s go down a level and change the configuration of the ssh daemon. Traditionally, we would do this sort of task with a shell script. The following snippet from a shell script is intended to add a line to __/etc/ssh/sshd_config__ to prevent ++root++ logins:

[source,shell]
----
echo "PermitRootLogin no" >> /etc/ssh/sshd_config
----

As is, this code will add a new line to the file every time it runs. It assumes that the file does not contain the line already. Of course, you can add checks for this, but the code quickly becomes unreadable:

[source,shell]
----
(grep -iq 'PermitRootLogin' /etc/ssh/sshd_config ||
 echo "PermitRootLogin no" >> /etc/ssh/sshd_config) &&
 sed -i 's/^.*PermitRootLogin.*$/PermitRootLogin no/;' /etc/ssh/sshd_config
----

This snippet uses the ++grep++ command to determine if the file alredady contains the ++PermitRootLogin++ string, and based on the result either adds the corresponding line or uses the ++sed++ command to edit the existing line.

Compare((("promises", "files: type")))((("files: promises"))) this with the equivalent CFEngine declaration:


[source,cf3]
----
files:
  "/etc/ssh/sshd_config" -> { "security_officer@example.net" }
    comment => "Disallow direct root login",
    edit_line => replace_or_add(".*PermitRootLogin.*",
                                "PermitRootLogin no");
----

The CFEngine policy will add the line only if it is not there already. Additionally, you can see that CFEngine rules allow comments as rule attributes. These comments can be made available as the policy executes, allowing administrators to better understand and debug the actions taken by CFEngine. CFEngine also allows setting a promisee or stakeholder for each promise (++"security_officer@example.net”++ in this example), which can be used to link promises together, or to indicate what or who might care about a particular promise.

Rules in CFEngine can be as detailed or as high-level as you wish. For example, you could generalize the SSH configuration file mechanism and express it like this (and we will look into the details of how to do this in <<editing-etcsshd_config>>):


[source,cf3]
----
include::{sourcedir}/ch03_2.cf[]
----

This((("promises", "vars: type")))((("vars: promises"))) CFEngine policy allows you to define arbitrary configuration parameters in the ++sshd++ array defined at the top (in the link:http://cf-learn.info/ref/vars[++vars:++] section), which((("promises", "files: type")))((("files: promises"))) will be applied by the link:http://cf-learn.info/ref/files[++files:++] section by modifying or adding only those parameters that need to be fixed. Finally, ++sshd++ will be restarted only if any changes were made. In other words, the promise of having the right parameters in the file could be satisfied just by checking that they’re set properly already (the “Promise kept” state described earlier), so the restart will take place only in the “Promise repaired” state.

Let’s go back to our description of promises, to start figuring out what is happening in this policy. The link:http://cf-learn.info/ref/vars[++vars:++] section is simply variable declarations—in this case, an array indexed by configuration parameter names, and containing the values of each parameter. In((("set_config_values() bundle"))) the link:http://cf-learn.info/ref/files[++files:++] section, the __/etc/ssh/sshd_config__ file promises to have its content edited according to the specifications contained in the ++set_config_values()++ __bundle__ (a named collection of CFEngine promises), and to set the ++restart_sshd++ class if the file needed to be repaired (i.e. modified to satisfy the promise). Finally, ((("class expressions", "restart_sshd::")))((("restart_sshd\:\: class expression")))((("promises", "commands: type")))((("commands: promises")))in the link:http://cf-learn.info/ref/commands[++commands:++] section, the command to restart ++sshd++ promises to run only if the ++restart_sshd++ class is set (if this class is set, it means that the file was modified, so the daemon needs to be restarted for the changes to take effect).

Not shown in this example is the ++set_config_values()++ bundle. This bundle is part of the CFEngine Standard Library (described in <<cfengine_stdlib>>), and which takes care of the actual editing of the file to set the desired parameters, using the built-in file-editing primitives in CFEngine. We will examine this bundle in detail in <<editing-etcsshd_config>>.

CFEngine allows you to express configuration policies at the level of abstraction you wish, leaving lower-level details out of sight but available when you need them. Now, let’s take a more detailed look at the syntax of a CFEngine (((range="endofrange", startref="ch3-ex")))policy.

[[cfengine-policy-structure]]
=== CFEngine Policy Structure

The ((("promises", id="ch3-prom", range="startofrange")))syntax of the CFEngine 3 configuration files is very uniform, since everything is a promise. In general, every element in a CFEngine policy has the following structure:


[source,cf3]
----
promise_type:
  class_expression::
    "promiser" -> { "promisee1", "promiseeX" }
        attribute1 => value1,
        attributeX => valueX;
        ...
----

The (((": (colon)", "following promise type")))((("\:\: (colon, double)", "following class expression")))((("-> (hyphen, right angle bracket), following promiser")))((("=> (equal sign, right angle bracket), following attributes")))((("equal sign, right angle bracket (=>), following attribute")))((("hyphen, right angle bracket (->), following promiser")))((("colon, double (::), following class expression")))((("colon (:)", "following promise type")))values that __++promise_type++__ can have depend on the type of container in which the promise is stored (and we will look at them in detail in <<containers>>). The((("attributes", seealso="specific attributes")))((("promisers"))) value of __++promise_type++__ determines how the __++"promiser"++__ is interpreted, which __++attributes++__ are valid and how their corresponding __++values++__ are used. The attribute values can be either constant values, variables of the types described in <<sec-cfengine-variables>>, or container names as described in <<containers>>. The type of allowed values is fixed for each attribute.

The((("promisees"))) __++promisees++__ are optional and, if specified, contain references to other promises that depend on the current one, and are used for documentation. In this way, we can specify which promises affect others or who might care about a particular promise. CFEngine has the ability to produce reports that include this information. Note that specifying promisees has no effect on the execution order of the policy, they are merely for informational purposes. Promisees can be arbitrary strings.

The((("class expressions"))) __++class_expression++__, if specified, allows the promise to be conditionally executed depending on the value of the expression. If ((("class expressions", "any::")))((("any\:\: class expression")))omitted it defaults to ++any++, which is always defined (you can also use the class expression line ++any::++ to make this explicit). We will look at them in detail in <<classes-and-decision-making>>.

Depending on the type of promise, almost all elements of this syntax, except for the __++promise_type++__ and the __++promiser++__, are optional. For example, to unconditionally execute a command, we would simply state it like this:


[source,cf3]
----
  commands:
      "/bin/ls /";
----

In((("promises", "commands: type")))((("commands: promises"))) this case link:http://cf-learn.info/ref/commands[++commands:++] is the promise type, and specifies that the promisers in the following section are to be interpreted as commands to execute. The promiser, ++"/bin/ls /"++ indicates the command to execute. Since no attributes are specified, the command will always be executed and its output reported by(((range="endofrange", startref="ch3-prom"))) CFEngine.


[TIP]
====
You can find some guidance on the style and form of policy writing in the link:https://cfengine.com/docs/3.5/manuals-writing-policy-policy-style-guide.html[CFEngine Policy Style Guide].

====

[[sec-cfengine-variables]]
==== Data Types and Variables in CFEngine

CFEngine supports different data types: scalars can be strings, integers or floating-point numbers; lists contain an ordered set of scalars, and arrays contain sets of values indexed by arbitrary strings. These data types can be used as constant values or be stored in variables.


===== Variable declarations

Variables((("promises", "vars: type")))((("vars: promises")))((("variables"))) in CFEngine are declared in the link:http://cf-learn.info/ref/vars[++vars:++] section (they are promises of type link:http://cf-learn.info/ref/vars[++vars:++]) of a bundle. link:http://cf-learn.info/ref/vars[++vars:++] is one of the common promise types (along with link:http://cf-learn.info/ref/classes[++classes:++] and link:http://cf-learn.info/ref/reports[++reports:++]) that can be included in any type of bundle. link:http://cf-learn.info/ref/vars[++vars:++] promises adhere to the common structure described in <<cfengine-policy-structure>>, which in this case is interpreted as follows:


[source,cf3]
----
  vars:
      "variable"
        type => value;
----

The((("promisers", "for variables"))) promiser is the name of the variable in quotes. The type of the variable is given as an attribute, and its value indicates the value to store in the variable. Normally you write the whole declaration in a single line for brevity, like this:


[source,cf3]
----
include::{sourcedir}/ch03_3.cf[]
----

The((("policy attribute"))) only valid attribute in variable declarations besides the type is link:http://cf-learn.info/ref/policy[++policy++], which defines whether a variable can be modified without warning. By default, CFEngine will give you a warning if you assign a new value to a previously-defined variable. If you know a variable will need to change value during the execution of the policy, you can avoid these warnings by setting link:http://cf-learn.info/ref/policy[++policy++] to ++"overridable"++ or ++"free"++ (they are synonyms).


[WARNING]
====
CFEngine will in any case change the value of the variable, link:http://cf-learn.info/ref/policy[++policy++] only controls whether you will get a warning.

====

Let us now look at the details of the different data types available in CFEngine.

[[sec-strings-and-numbers]]
===== Strings

Strings((("string data type", id="ch3-string", range="startofrange")))((("data types", id="ch3-dt", range="startofrange"))) in CFEngine are declared using the string type. String((("quotes (" " or ' '), enclosing string values")))((("backslash (\), escaping quotes in string values")))((("\ (backslash), escaping quotes in string values"))) values must always be enclosed by single or double quotes (there is no difference in their behavior). If you need to include a double quote in a double-quoted string, you need to precede it with a backslash (and similarly for single quotes inside single-quoted strings). You can create multiline strings simply by splitting them across multiple lines. To((("$ (dollar sign), preceding variable references")))((("( ) (parentheses)", "enclosing variable references")))((("{ } (curly braces), enclosing variable references")))((("curly braces ({ }), enclosing variable references")))((("parentheses &#x28;&#x28; &#x29;&#x29;", "enclosing variable references")))((("dollar sign ($), preceding variable references"))) reference a string variable (and any scalar variable), you need to enclose the variable name in parentheses or curly braces, and precede them with a dollar sign.

You can interpolate variables into a string simply by referencing them inside the string. The following example shows some examples of strings:


[source,cf3]
----
include::{sourcedir}/ch03_4.cf[]
----

If you save this short policy into a file and run it, you will get the following output:

[source,console]
----
# cf-agent --no-lock --inform -f ./vars_string_examples.cf
2013-10-14T05:22:19+0000   notice: /test: R: s1 = one
2013-10-14T05:22:19+0000   notice: /test: R: s2 = this
is a
multine string
2013-10-14T05:22:19+0000   notice: /test: R: s3 = with "quotes"
----

Note that the strings in the link:http://cf-learn.info/ref/reports[++reports:++] section adhere to the same rules, and contain the interpolated values of the declared(((range="endofrange", startref="ch3-string"))) variables.


===== Numbers

CFEngine((("real data type", id="ch3-num", range="startofrange")))((("int data type", id="ch3-num2", range="startofrange")))((("numeric data types", id="ch3-num3", range="startofrange"))) supports both integers and floating-point numbers, denoted by the int and real types. Note that numeric values are also given as strings in CFEngine, but they are checked for validity before they are stored in the variable. For(((""G" or "g" in numbers")))(((""M" or "m" in numbers")))(((""K" or "k" in numbers"))) integers, CFEngine supports the suffixes ++k++, ++m++, and ++g++ to represent powers of 10 (that is, 1000, etc.), and the suffixes ++K++, ++M++, and ++G++ to represent powers of 2 (that is, 1024, etc.). Real numbers can be specified in decimal or exponential notation. For example:


[source,cf3]
----
include::{sourcedir}/ch03_5.cf[]
----

Produces the following (((range="endofrange", startref="ch3-num3")))(((range="endofrange", startref="ch3-num2")))(((range="endofrange", startref="ch3-num")))output:

[source,console]
----
# cf-agent --no-lock --inform -f ./vars_num_examples.cf
2013-10-14T05:23:17+0000   notice: /test: R: i1 = 25
2013-10-14T05:23:17+0000   notice: /test: R: i2 = 10000
2013-10-14T05:23:17+0000   notice: /test: R: i3 = 10240
2013-10-14T05:23:17+0000   notice: /test: R: r1 = 1.200000
2013-10-14T05:23:17+0000   notice: /test: R: r2 = 0.000100
----

[[sec-lists]]
===== Lists

CFEngine((("rlist data type", id="ch3-list", range="startofrange")))((("ilist data type", id="ch3-list2", range="startofrange")))((("slist data type", id="ch3-list3", range="startofrange")))((("lists", id="ch3-list4", range="startofrange"))) supports ordered lists of any of the scalar types: lists of strings (slist), lists of integers (ilist) and lists of reals (rlist). In all cases, the values have to be specified as strings, but they are interpreted and validated according to the declared type. You can assign and store lists across variables of different types, as long as the values are compatible. This means you can always assign an ilist or an rlist into an slist, but you can assign an slist into an ilist or rlist only if it contains valid values according to the type of the destination variable.

You((("@ (at-sign), preceding list variable references")))((("at-sign (@), preceding list variable references"))) can refer to list variables by using an at-sign (++@++) before the variable name. By doing this you can pass the whole list to a function that expects a list argument. You can also specify a list as part of another list value, and it will be expanded in place. The following example illustrates these points:


[source,cf3]
----
include::{sourcedir}/ch03_6.cf[]
----

When you run it you get the following output:

[source,console]
----
# cf-agent --no-lock --inform -f ./vars_list_examples.cf
2013-10-14T05:23:40+0000   notice: /test: R: l3 = one
2013-10-14T05:23:40+0000   notice: /test: R: l3 = two
2013-10-14T05:23:40+0000   notice: /test: R: l3 = three
2013-10-14T05:23:40+0000   notice: /test: R: l3 = 1
2013-10-14T05:23:40+0000   notice: /test: R: l3 = 2
2013-10-14T05:23:40+0000   notice: /test: R: l3 = 3
2013-10-14T05:23:40+0000   notice: /test: R: l3 = 1.0
2013-10-14T05:23:40+0000   notice: /test: R: l3 = 2.0
2013-10-14T05:23:40+0000   notice: /test: R: l3 = 3.0
----

Both ++@(l1)++ and ++@(l2)++ are being expanded inside ++@(l3)++, so that its final value is this:


[source,cf3]
----
   { "one", "two", "three", "1", "2", "3", "1.0", "2.0", "3.0" }
----

In((("implicit looping")))((("looping"))) this example we are also using CFEngine implicit looping by referring to the ++@(l3)++ array as a scalar ++$(l3)++. See <<looping-in-cfengine>> for a full explanation of how this (((range="endofrange", startref="ch3-list4")))(((range="endofrange", startref="ch3-list3")))(((range="endofrange", startref="ch3-list2")))(((range="endofrange", startref="ch3-list")))works.

[[sec-arrays]]
===== Arrays

Arrays((("arrays"))) are sets of values indexed by a string (they are commonly called __hashes__ in other programming languages). Array elements can contain scalars, lists or other arrays, even within the same array.

In((("[ ] (brackets), enclosing array indexes")))((("brackets ([ ]), enclosing array indexes"))) CFEngine, arrays are declared element by element, as if they were regular variables, except their name contains the index surrounded by brackets. There is no shortcut for declaring the whole array in a single step. There((("getvalues() function")))((("getindices() function"))) are certain functions that operate on arrays, such as link:http://cf-learn.info/ref/getindices[++getindices()++] and link:http://cf-learn.info/ref/getvalues[++getvalues()++], and they receive as argument the name of the array as a string. For example, we could use an array to store user account information:

[source,cf3]
----
include::{sourcedir}/ch03_7.cf[]
----

This example is intentionally contrived to show how you can store different data types in an array. Note how ++@(fields)++ is being automatically populated by link:http://cf-learn.info/ref/getindices[++getindices()++] based on the indices declared for the ++user++ array. In other words, the statement:


[source,cf3]
----
      "fields"     slist => getindices("user");
----

creates a variable named ++fields++ that refers to a list of three strings taken from the indices: ++name++, ++fullname++, and ++dirs++. The((("implicit looping")))((("looping"))) list can then be used to loop through the ++user++ array, like before. Additionally, ++@(userfields)++ is being populated with the indices of the array stored in ++user[fullname]++:


[source,cf3]
----
      "userfields" slist => getindices("user[fullname]");
----

Finally, observe that ++user[dirs]++ contains a list of strings, and we are looping over that list as we would over a regular list variable (such as ++@(fields)++ or ++@(userfields)++ in this example) by referencing it as a scalar:


[source,cf3]
----
      "user dir = $(user[dirs])";
----

Here is its (((range="endofrange", startref="ch3-dt")))output:

[source,console]
----
# cf-agent --no-lock --inform -f ./vars_array_examples2.cf
2013-10-14T05:27:44+0000   notice: R: user fields = name
2013-10-14T05:27:44+0000   notice: R: user fields = fullname
2013-10-14T05:27:44+0000   notice: R: user fields = dirs
2013-10-14T05:27:44+0000   notice: R: account name = zamboni
2013-10-14T05:27:44+0000   notice: R: first name = Diego
2013-10-14T05:27:44+0000   notice: R: last name = Zamboni
2013-10-14T05:27:44+0000   notice: R: user dir = /home/zamboni
2013-10-14T05:27:44+0000   notice: R: user dir = /tmp/zamboni
2013-10-14T05:27:44+0000   notice: R: user dir = /export/home/zamboni
----

[[classes-and-decision-making]]
==== Classes and Decision Making

Classes((("classes", id="ch3-class", range="startofrange"))) are the key to controlling flow and making decisions in a CFEngine policy. In CFEngine, classes((("classes", "as boolean values"))) are named boolean values((("boolean values", "classes as"))) that can be either __true__ (the class is defined) or __false__ (the class is undefined). Classes can represent any characteristic of the system, information that is known (true) or unknown (false), or any condition that you want to indicate in the policy. They can be volatile (they stop existing as soon as the current CFEngine run is over) or persistent for a period of time you define. While many important classes are predefined by CFEngine (hard classes), you can define others for your particular needs (soft classes).

Hard classes:: 
    These((("hard classes", id="ch3-hard", range="startofrange")))((("classes", "hard classes", id="ch3-hard2", range="startofrange"))) are defined automatically by CFEngine when it runs, and represent mainly information about the system or the current environment that is discovered by CFEngine. Examples of hard classes include:
+
--
* Host information (e.g., class ++doomsday++ would be defined if the hostname of the machine where link:http://cf-learn.info/ref/cf-agent[++cf-agent++] is running is “doomsday” and class ++ipv4_192_168_1_2++ would be defined if the host’s IP address is 192.168.1.2).
* Time information (e.g., class ++Hr5++ would be set if CFEngine is running between 5 and 6 AM, class ++Min15_20++ is defined if it is currently between minutes 15 and 20 of the hour, and class ++Mon++ would be set if it’s Monday).
* Operating system information (e.g., ++linux++ would be set on any Linux system, and ++suse_9++ would be set if the Linux distribution is SuSE 9).

To see the full list of hard classes defined on a particular system, run the following command (example output from an Ubuntu policy server at 4:28 UTC on a (((range="endofrange", startref="ch3-hard2")))(((range="endofrange", startref="ch3-hard")))Friday):

[source,console]
----
# cf-promises -v | grep classes
2013-09-13T04:28:43+0000  verbose: Discovered hard classes: 10_0_2_15
127_0_0_1 192_168_122_1 2_cpus 64_bit Day13 Friday GMT_Hr4 Hr04 Hr04_Q2
Lcycle_0 Min25_30 Min28 Night PK_MD5_cd178888ee05e6a3461d4a2707ba9f97
Q2 September Yr2013 am_policy_hub any cfengine cfengine_3
cfengine_3_6 cfengine_3_6_0a1 cfengine_3_6_0a1_c861b92 common
compiled_on_linux_gnu debian debian_wheezy fe80__a00_27ff_fefe_aaaf
have_aptitude inform_mode ipv4_10 ipv4_10_0 ipv4_10_0_2
ipv4_10_0_2_15 ipv4_127 ipv4_127_0 ipv4_127_0_0 ipv4_127_0_0_1
ipv4_192 ipv4_192_168 ipv4_192_168_122 ipv4_192_168_122_1 linux
linux_3_2_0_23_generic linux_x86_64 linux_x86_64_3_2_0_23_generic
linux_x86_64_3_2_0_23_generic__36_Ubuntu_SMP_Tue_Apr_10_20_39_51_UTC_2012
localhost mac_08_00_27_fe_aa_af mac_be_1c_95_4f_d7_c3 net_iface_eth0
net_iface_lo net_iface_virbr0 policy_server precise64 ubuntu ubuntu_12
ubuntu_12_4 verbose_mode x86_64
----
--

Soft classes:: 
    These((("soft classes")))((("classes", "soft classes"))) are defined by the policy during its execution. For example, a class could be defined in the following cases:
+
--
* Depending((("promises", "classes: type")))((("classes: promises")))((("fileexists() function"))) on whether a certain file exists. In this example, we set the ++devel_host++ class if the __/var/sitedata/devel_host.flag__ file exists, using the built-in link:http://cf-learn.info/ref/fileexists[++fileexists()++] function to perform the check:
+
[source,cf3]
----
classes:
  "devel_host" expression =>
                 fileexists("/var/sitedata/devel_host.flag");
----
+
Setting a class like this might be useful, for example, to establish whether certain executable programs or other capabilities are present on a system before invoking them, or to apply different configurations to the system.

* As a Boolean expression of other classes. In this example, ++test_host++ will be defined if any of ++testhost1++, ++testhost2++, or ++testhost3++ classes is defined. These might be the hostnames of the machines in which you want the ++test_host++ class to be defined:
+
[source,cf3]
----
classes:
  "test_host" or => { "testhost1", "testhost2", "testhost3"};
----
+
Setting a class like this might be useful to run certain operations on certain systems—tests in this case.

* As((("classes attribute"))) an indication of the status of a particular promise. In this example, if any changes are made to the __/etc/ssh/sshd_config__ file by the link:http://cf-learn.info/ref/edit_line[++edit_line++] attribute, CFEngine would consider the promise as __repaired__, in which case the ++restart_sshd++ class will be defined:
+
[source,cf3]
----
files:
  "/etc/ssh/sshd_config"
    edit_line => set_config_values("sshd"),
    classes   => if_repaired("restart_sshd");
----
+
Setting a class like this might be useful to keep track of the state of the system, and make sure that CFEngine follows up on an operation during its next pass.

Note that classes can be explicitly defined in a link:http://cf-learn.info/ref/classes[++classes:++] section, but as you can see in the third example, they can also be defined by the common link:http://cf-learn.info/ref/classes[++classes++] attribute, which you can use in all promises to set or unset classes based on the result of the promise. Several((("always classes body")))((("if_else classes body")))((("if_notkept classes body")))((("if_ok classes body")))((("if_repaired classes body")))((("bodies", "classes bodies", see="classes bodies")))((("classes bodies", "list of"))) link:http://cf-learn.info/ref/classes[++classes++] bodies are predefined in the CFEngine standard library, including ++if_repaired++, ++if_ok++, ++if_notkept++, ++if_else++, ++always++ and ++classes_generic++.
 
[TIP]
====
The ((("classes bodies", "classes_generic()")))((("classes_generic() classes body")))classes_generic body provides a useful way to set consistent class names depending on the outcome of a promise. If you specify, for example:

[source,cf3]
----
  classes => classes_generic("foo");
----
 
Then, depending on the state of the promise, you will get one of ++foo_repaired++, ++foo_failed++, ++foo_denied++, ++foo_timeout++ or ++foo_kept++ defined. This body also defines a few other class name patterns, including ++foo_reached++, which gets defined regardless of the promise outcome and can be used to determine if a promise has been evaluated at all.
====
--

[[I_sidebar3_d1e3965]]
.Classes and Contexts
****
You((("classes", "as contexts")))((("contexts"))) may see “classes” described sometimes as “contexts”. This term expresses the idea of a particular __context__ (be it time or date, operating system, architecture, etc.) in which a host is at the moment. The CFEngine team has decided to keep using __class__ in all official documentation to avoid confusion, but __context__ might still be used in some explanations when it makes things clearer.


****


Apart((("class expressions", id="ch3-exp", range="startofrange"))) from defining classes, you need a way to act on them. This is what the __++class_expression++__ shown in <<cfengine-policy-structure>> is for. A ((("boolean expressions", see="class expressions")))((("AND operator (& or .), in class expressions")))((("OR operator (|), in class expressions")))((("NOT operator (!), in class expressions")))((("! (exclamation point), NOT operator")))((("exclamation point (!), NOT operator")))((("| (vertical bar), OR operator")))((("vertical bar (|), OR operator")))((("ampersand (&), AND operator")))((("& (ampersand), AND operator")))((("period (.)", "AND operator")))(((". (period)", "AND operator")))class expression in CFEngine is a boolean expression constructed with class names and the boolean operators AND (++&++ or ++.++), OR (++|++) and NOT (++!++). Parenthesis((("( ) (parentheses)", "in class expressions")))((("parentheses &#x28;&#x28; &#x29;&#x29;", "in class expressions"))) can be used to group parts of the expression. When a line ends with a double colon, it is evaluted as a class expression. Only if the class expression is true are the lines that follow evaluated. The following are examples of valid class expressions:


[source,cf3]
----
# True if the linux class is defined
linux::
# True if both reboot_needed and linux are defined
reboot_needed.linux::
# True if reboot_needed is defined and neither linux nor windows are defined
reboot_needed.!(linux|windows)::
# The any class is always defined, so whatever follows will always be evaluated
any::
----

Additionally, ((("ifvarclass attribute")))you can use the link:http://cf-learn.info/ref/ifvarclass[++ifvarclass++] attribute in most promise types to condition the evaluation of one promise to the result of the included class expression. For example, the following two promises are equivalent:


[source,cf3]
----
commands:
  # First command is conditioned by the ifvarclass attribute
  "/usr/sbin/shutdown -r now"
    ifvarclass => "linux";

  # Second command is conditioned by the class expression before it
  linux::
    "/usr/sbin/shutdown -r now";
----

The link:http://cf-learn.info/ref/ifvarclass[++ifvarclass++] attribute allows you to place a condition around a single promise. It has the advantage of specifying the class expression as a string, which means you can use variables in the class expression, and they will be expanded before evaluating the expression. This allows a lot of flexibility in the types of conditions that you can use. For example, you can construct class names on the fly using variables:


[source,cf3]
----
include::{sourcedir}/ch03_8.cf[]
----

In this example, the link:http://cf-learn.info/ref/reports[++reports:++] section is looping through all the strings in the ++@(words)++ list (see <<looping-in-cfengine>>), and the corresponding message is printed depending on whether the class named after the current value is defined. Note how the class expression for the second report (“not defined”) includes the NOT character at the beginning. Here is its output on a Mac (whose base operating system is Darwin, so the ++darwin++ class is defined):

[source,console]
----
# cf-agent --no-lock --inform -f ./ifvarclass_examples.cf
2013-10-14T00:34:51-0500   notice: R: Class darwin is defined
2013-10-14T00:34:51-0500   notice: R: Class apple is not defined
2013-10-14T00:34:51-0500   notice: R: Class table is not defined
2013-10-14T00:34:51-0500   notice: R: Class linux is not defined
----

Class((("promises", "classes: type")))((("classes: promises")))((("expression attribute"))) expressions can also be used to define other classes using the link:http://cf-learn.info/ref/expression[++expression++] attribute in a link:http://cf-learn.info/ref/classes[++classes:++] promise. For example, the ++test_host++ class shown above could also be defined like(((range="endofrange", startref="ch3-exp"))) this:


[source,cf3]
----
classes:
  "test_host" expression => "testhost1|testhost2|testhost3";
----

Finally, ((("persistence attribute")))((("persistent classes")))((("classes", "persistent")))classes can be made persistent, even across invocations of link:http://cf-learn.info/ref/cf-agent[++cf-agent++], by using the link:http://cf-learn.info/ref/persistence[++persistence++] attribute in the class declaration. Its value should be the length of time, in minutes, for which the class should retain its value after being evaluated. This can be useful if the class value is the result of a time-consuming or otherwise expensive operation, to avoid recomputation every time link:http://cf-learn.info/ref/cf-agent[++cf-agent++] runs.

Note that setting a class as persistent does not mean it will not be reevaluated every time cf-agent runs, only that its previous value will be available during the persistence period. To ((("classes", "flag classes")))((("flag classes")))avoid unnecessary reevaluation, the usual practice is to use a “flag class” with the same persistence period. For example:


[source,cf3]
----
include::{sourcedir}/ch03_9.cf[]
----

In this case, we are using ++cache_is_active++ as the “flag class” to indicate whether we should recompute the value of ++line_exists++, which would arguably be a very costly class to compute. In((("regline() function"))) this case we are using link:http://cf-learn.info/ref/regline[++regline()++] to look for a line containing “foo” in the file __/tmp/test_data.txt__). In the link:http://cf-learn.info/ref/classes[++classes:++] section, we evaluate the classes only when ++cache_is_active++ is not defined. In this case, we set ++cache_is_active++ unconditionally (using the special expression ++"any"++), and set ++line_exists++ depending on the result of the function, both with the same persistence period. This means that within one minute, no matter how many times ++cf-agent++ executes, the classes will not be reevaluated and their cached values will be reported. You can test this behavior in the previous example by running it, then editing the file, and observing that the changes are not detected until a minute has passed since the last execution. In deployment, this can be extremely useful to limit reevaluation of complex or costly class expressions whose values change slowly or (((range="endofrange", startref="ch3-class")))infrequently.

[[containers]]
==== Bundles, Bodies, and Namespaces

CFEngine policies can grow quite complex, so it would not be very scalable simply to list promises back to back. For this reason, and to promote reusability, CFEngine groups its syntax elements into two types of structures: __bundles__ and __bodies__, and they in turn can be grouped into __namespaces__.


===== Bundles

Bundles are the most general and powerful grouping mechanism. They are the only elements that can contain promises. A bundle can contain many promises, possibly separated into sections. The structure described at the beginning of <<cfengine-policy-structure>> can be contained only inside a bundle. Bundles are defined as follows:


[source,cf3]
----
bundle type name(arguments)
{
  promise_type:
    class_expression::
      promise
      ...
}
----

The __name__ of the bundle is an arbitrary string that you can use to identify it. The __type__ of the bundle has to be one of the CFEngine-recognized types, and it defines the semantics of the bundle (that is, how are the promises in it interpreted), as well as the promise type sections it can contain. All bundles can receive an arbitrary number of arguments. If no arguments are needed, the parenthesis are optional.

The bundle types defined by CFEngine are:

link:http://cf-learn.info/ref/agent[ ++agent++ ]:: 
    Bundles((("bundles", "agent type")))((("agent bundles"))) of type link:http://cf-learn.info/ref/agent[++agent++] are “executable” bundles that can be called from the main link:http://cf-learn.info/ref/bundlesequence[++bundlesequence++] declaration, or as method calls in the link:http://cf-learn.info/ref/methods[++methods:++] section of another agent bundle. In this respect they could be compared to subroutines in other programming languages. They are the most extensive and powerful type of bundle, and the ones that actually implement any changes that we want to make in the system. These((("promises", "in agent bundles"))) bundles can contain the following promise types:
 
* link:http://cf-learn.info/ref/commands[++commands:++] to ((("promises", "commands: type")))((("commands: promises")))specify commands to be executed


* link:http://cf-learn.info/ref/files[++files:++] to ((("promises", "files: type")))((("files: promises")))edit and manipulate files


* link:http://cf-learn.info/ref/methods[++methods:++] to ((("promises", "methods: type")))((("methods: promises")))call other agent bundles


* link:http://cf-learn.info/ref/packages[++packages:++] to ((("promises", "packages: type")))((("packages: promises")))query and manipulate software packages in the system


* link:http://cf-learn.info/ref/processes[++processes:++] to ((("promises", "processes: type")))((("processes: promises")))query and manipulate running processes


* link:http://cf-learn.info/ref/storage[++storage:++] to ((("promises", "storage: type")))((("storage: promises")))query and configure file systems


* link:http://cf-learn.info/ref/services[++services:++] to ((("promises", "services: type")))((("services: promises")))configure system services in Unix-like systems (CFEngine Enterprise also supports Windows system services)


* link:http://cf-learn.info/ref/databases[++databases:++] to ((("promises", "databases: type")))((("databases: promises")))manipulate and configure databases


* link:http://cf-learn.info/ref/guest_environments[++guest_environments:++] to ((("promises", "guest_environments: type")))((("guest_environments: promises")))manipulate and configure virtual environments


link:http://cf-learn.info/ref/common[ ++common++ ]:: 
    Bundles((("bundles", "common type")))((("common bundles"))) of this type are just like link:http://cf-learn.info/ref/agent[++agent++] bundles, but are special in two big ways:
+
--
* The variables and classes defined in them are automatically available to every other bundle in your policy.
* They are evaluated by all the CFEngine components (++cf-agent++, ++cf-serverd++, ++cf-monitord++, etc.)

For these reasons, they are a good place to define globally useful variables and classes. For example:

[source,cf3]
----
include::{sourcedir}/ch03_10.cf[]
----

This ((("period (.)", "in variable reference")))(((". (period)", "in variable reference")))((("dot (.), in variable reference")))((("variables", "referencing from another bundle")))example defines two variables with strings that will be useful in other parts of the policy, and which we can reference as ++$(g.localdir)++ and ++$(g.confdir)++ (in general, any variable can be accessed from anywhere else by prefixing it with the name of the bundle where it was defined). Also defined is a class based on whether either of the classes ++testhost1++ or ++testhost2++ is defined (this would be the case if the current host has any of those names, and is a common way of defining a class for a certain group of hosts—more on this in <<sec-defining-classes-for-groups-of-hosts>>). This class is automatically made global, which means it can be used in any other bundle.

[[I_sidebar3_d1e4574]]
.Class and Variable Scoping
****

All ((("variables", "scope of")))((("classes", "scope of")))((("scope", "of classes")))((("scope", "of variables")))variables in CFEngine are local to the bundle in which they are defined. However, they can be accessed from any other bundle by prefixing them with the bundle name in which they are defined, separated by a dot, as in ++$(g.localdir)++.

Most classes in CFEngine are local to the bundle in which they are defined, and they cannot be accessed from anywhere else (there is no mechanism for specifying the bundle of a class). The exceptions are:

* Classes((("global classes"))) defined in a link:http://cf-learn.info/ref/common[++common++] bundle are automatically global.

* Classes((("classes attribute"))) defined by the link:http://cf-learn.info/ref/classes[++classes++] attribute in a promise (as a result of its status) are automatically global. This is useful because these classes are commonly used as a signaling mechanism across promises and bundles.

* Since((("classes bodies", "scope of")))((("promises", "classes: type")))((("classes: promises"))) CFEngine 3.5.0, both link:http://cfengine.com/docs/3.5/reference-promise-types-classes.html[++classes:++] promises and link:http://cfengine.com/docs/3.5/reference-promise-types.html#classes[++classes++] bodies can specify a ((("scope attribute")))scope attribute, which can take the values ++“bundle”++ (the default for ++classes:++ promises) and ++“namespace”++ (the default for ++classes++ bodies)

****
 
[WARNING]
====
Note that link:http://cf-learn.info/ref/common[++common++] bundles are not necessarily evaluated before regular link:http://cf-learn.info/ref/agent[++agent++] bundles, although this is a common misconception. You can (and should) put them in link:http://cf-learn.info/ref/bundlesequence[++bundlesequence++] to ensure they are evaluated at the correct moment (normally, you would put them at the beginning of the execution sequence, to ensure the values defined in them are properly available to all other bundles).

====
--

link:http://cf-learn.info/ref/edit_line[ ++edit_line++ ]:: 
    Bundles((("bundles", "edit_line type")))((("edit_line bundles"))) of type link:http://cf-learn.info/ref/edit_line[++edit_line++] can be used to change a file, one of the most common and most complex operations performed by CFEngine. These bundles must be specified as the value of the link:http://cf-learn.info/ref/edit_line[++edit_line++] attribute in a file-editing promise (this is, a promise of type link:http://cf-learn.info/ref/files[++files:++]). link:http://cf-learn.info/ref/edit_line[++edit_line++] bundles themselves can be quite complex and contain((("promises", "in edit_line bundles"))) their own set of allowable promise types, which include:
 
* link:http://cf-learn.info/ref/insert_lines[++insert_lines:++] to ((("promises", "insert_lines: type")))((("insert_lines: promises")))add lines to a file


* link:http://cf-learn.info/ref/delete_lines[++delete_lines:++] to ((("promises", "delete_lines: type")))((("delete_lines: promises")))remove lines from a file


* link:http://cf-learn.info/ref/field_edits[++field_edits:++] to ((("promises", "field_edits: type")))((("field_edits: promises")))make field-oriented changes in a file


* link:http://cf-learn.info/ref/replace_patterns[++replace_patterns:++] to ((("promises", "replace_patterns: type")))((("replace_patterns: promises")))make regular expression substitutions in a file


link:http://cf-learn.info/ref/server[ ++server++ ]:: 
    Bundles((("cf-serverd process")))((("bundles", "server type")))((("server bundles"))) of type link:http://cf-learn.info/ref/server[++server++] control the behavior of the link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] process, which has the task of serving files to other CFEngine machines that request them (link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] normally runs on the CFEngine policy hub). This((("promises", "in server bundles"))) type of bundle can contain two promise types:
 
* link:http://cf-learn.info/ref/access[++access:++] to ((("promises", "access: type")))((("access: promises")))define access permissions to different resources on the server.


* link:http://cf-learn.info/ref/roles[++roles:++] to ((("promises", "roles: type")))((("roles: promises")))define which users can indicate classes (and which classes they can define) in the server process, to alter the behavior of the link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] daemon. One of CFEngine’s strong security features is that remote machines can never execute arbitrary commands. Instead, they can execute certain bundles. Some users, as defined by link:http://cf-learn.info/ref/roles[++roles:++] promises, may have the ability to set custom classes when invoking those remote promises, thus allowing them to modify the promises’ behavior, but only as allowed by the remote bundle and its handling of the defined classes.


link:http://cf-learn.info/ref/monitor[ ++monitor++ ]:: 
    Bundles((("Commercial/Enterprise Edition", "monitor bundles")))((("bundles", "monitor type")))((("monitor bundles"))) of this type are supported only in commercial editions of CFEngine. They define custom parameters that CFEngine can monitor automatically, and specify how to react to changes in their values. CFEngine natively knows how to monitor a large set of system values, such as CPU and memory utilization. This((("promises", "in monitor bundles"))) type of bundle supports only ((("promises", "measurements: type")))((("measurements: promises")))one section called link:http://cf-learn.info/ref/measurements[++measurements:++], which contains promises defining what and how to monitor it, and how to react to changes.


Certain((("promises", "in all bundles"))) generic promise types are allowed in all bundle types:


* link:http://cf-learn.info/ref/vars[++vars:++] to ((("promises", "vars: type")))((("vars: promises")))define variables


* link:http://cf-learn.info/ref/classes[++classes:++] to ((("promises", "classes: type")))((("classes: promises")))define classes


* link:http://cf-learn.info/ref/reports[++reports:++] to ((("promises", "reports: type")))((("reports: promises")))define produced output


* link:http://cf-learn.info/ref/meta[++meta:++] to ((("promises", "meta: type")))((("meta: promises")))define metadata about a bundle.

[[sec-bodies]]
===== Bodies

Bodies ((("bodies", id="ch3-bodies", range="startofrange")))((("attributes")))are collections of attributes and values that can be used as values to other attributes. Bodies cannot contain promises nor sections, although they can receive arguments, and can contain class expressions to specify different values for some of the attributes. Bodies, just like bundles, have a type, which indicates the attribute to which they can be passed, as well as the attributes they can contain. The generic structure of a body is:

[source,cf3]
----
body type name(arguments)
{
  attribute1 => value1;
  attribute2 => value2;
  ...
[class_expression::]
  attributeN => valueN;
}
----

Some common bodies you will use include:

* link:http://cf-learn.info/ref/control[++control++] bodies((("bodies", "control types", id="ch3-ctrl", range="startofrange")))((("control bodies", id="ch3-ctrl2", range="startofrange"))) are special structures that are not referenced in any promises, but that control the behavior of different aspects of CFEngine itself. There are different types of control bodies, depending on the component whose behavior they control. The ((("bodies", "common control")))((("common control bodies")))((("control bodies", "common control")))one you are bound to use is the ++common control++ body. Among((("inputs attribute")))((("bundlesequence attribute")))((("policies", "bundlesequence attribute for"))) other things, it is in this body that you specify which bundles will be executed in your policy and in which order, using the link:http://cf-learn.info/ref/bundlesequence[++bundlesequence++] attribute, and which additional files to read, using the link:http://cf-learn.info/ref/inputs[++inputs++] attribute:
+ 
[source,cf3]
----
body common control
{
        inputs => { "tests.cf" };
        bundlesequence => { "test" };
}
----
+
--
This block tells CFEngine to load the file __tests.cf__ and to execute the ++test++ bundle. Every CFEngine policy needs to have a link:http://cf-learn.info/ref/bundlesequence[++bundlesequence++] definition, and this is most commonly done through a link:http://cf-learn.info/ref/control-common[++common control++] body. (You can also specify it with the ++-b++ option to link:http://cf-learn.info/ref/cf-agent[++cf-agent++], but I normally do this only when testing policy components.)

As you might imagine, link:http://cf-learn.info/ref/control-common[++common control++] supports many other attributes that specify global CFEngine behavior. There are also link:http://cf-learn.info/ref/control[++control++] bodies for specific CFEngine components, including the following:
 
* ++agent control++ bodies((("bodies", "agent control")))((("agent control bodies")))((("control bodies", "agent control"))) to specify promise-evaluation behavior such as minimum time between consecutive evaluations of the same promise (link:http://cf-learn.info/ref/ifelapsed[++ifelapsed++]), classes that tell CFEngine to abort (link:http://cf-learn.info/ref/abortclasses[++abortclasses++]), and many others.


* ++server control++ bodies((("bodies", "server control")))((("server control bodies")))((("control bodies", "server control"))) to specify server behavior, such as addresses and users from which connections will be allowed (link:http://cf-learn.info/ref/allowconnects[++allowconnects++], link:http://cf-learn.info/ref/allowusers[++allowusers++]) and the interface to which the link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] process should bind (link:http://cf-learn.info/ref/bindtointerface[++bindtointerface++]).


* Others such as link:http://cf-learn.info/ref/control-monitor[++monitor control++], ++runagent control++, link:http://cf-learn.info/ref/control-executor[++executor control++], ++hub control++ (((range="endofrange", startref="ch3-ctrl2")))(((range="endofrange", startref="ch3-ctrl")))and link:http://cf-learn.info/ref/file-control[++file control++].
--

* link:http://cf-learn.info/ref/classes[++classes++] bodies((("classes bodies"))) specify which classes will be defined depending on the outcome of a promise. These bodies are valid attributes for all promise types. For example, consider the following file promise:
+
--
[source,cf3]
----
"/var/run/somefile"
  create => "true",
  classes => passfail;
----

In this case, ++passfail++ is the name of a body, of type link:http://cf-learn.info/ref/classes[++classes++], that needs to be defined somewhere else. For example:

[source,cf3]
----
body classes passfail
{
  promise_kept     => { "fileexisted" };
  promise_repaired => { "filecreated" };
  repair_failed    => { "fileerror" };
}
----

There ((("classes attribute")))are several things you should notice here. First, the type of the body part is link:http://cf-learn.info/ref/classes[++classes++], which means it can be used only as the value of a link:http://cf-learn.info/ref/classes[++classes++] attribute in a promise. The name ++passfail++ is an arbitrary identifier. The((("repair_failed attribute")))((("promise_repaired attribute")))((("promise_kept attribute"))) link:http://cfengine.com/docs/3.5/reference-promise-types.html#classes[documentation for the classes body type] lists the attributes it can contain. In this case, if __/var/run/somefile__ already existed (the promise was __kept__), the ++fileexisted++ class will be defined after the promise runs. If __/var/run/somefile__ did not exist and CFEngine was able to create it (the promise was __repaired__), ++filecreated++ will be defined. And if the file cannot be created for some reason (the __repair failed__), the ++fileerror++ class will be defined. These classes can be used later on to control other promises. And more importantly, the ++passfail++ body can be used in many different promises, allowing for encapsulation and code reutilization.

An((("bodies", "parameters for"))) important thing to notice is that body parts can also have parameters, which allows even further customization of their behavior. For example, suppose we want the repaired/kept/failed classes to contain an arbitrary identifier to help us differentiate among multiple file checks. We could define ++passfail++ as follows:

[source,cf3]
----
body classes passfail(id)
{
  promise_kept     => { "$(id)_existed" };
  promise_repaired => { "$(id)_created" };
  repair_failed    => { "$(id)_error" };
}
----

We would then have to modify the files promises to something like this:

[source,cf3]
----
"/var/run/somefile"
  create => "true",
  classes => passfail("somefile");
----

Now ++"somefile"++ is being passed as an argument to the ++passfail++ body part, and used as part of the class names to define. This means that depending on the result of the promise, the classes ++somefile_existed++, ++somefile_created++ or ++somefile_error++ will be defined, instead of the generic names we had used before.
 
[TIP]
====
The((("classes bodies", "classes_generic()")))((("classes_generic() classes body"))) ++classes_generic++ body defined in the CFEngine Standard Library behaves much like our ++passfail++ body, but considers all possible promise outcomes, and defines several classname patterns for each outcome. For example, if a promise is repaired and you call ++classes_generic("somefile”)++ you will get the following classes defined: ++promise_repaired_somefile++, ++somefile_repaired++, ++somefile_ok++ and ++somefile_reached++.

====
--

* link:http://cf-learn.info/ref/action[++action++] is ((("action attribute")))((("action bodies")))((("bodies", "action type")))another attribute that can be used in any promise, and defines how the promise should be evaluated and fixed. Using it we can define that promises should only be checked but not fixed, whether the actions related to the promise should occur in the background, how often promises should be checked, logging behavior for the promise, and other attributes. For example, the following promise will warn if a certain line does not exist in ++/etc/motd++, and will issue the warning only every hour, even if CFEngine checks more frequently:
+
[source,cf3]
----
include::{sourcedir}/ch03_11.cf[]
----

* link:http://cf-learn.info/ref/copy_from[++copy_from++] is ((("bodies", "copy_from type")))((("copy_from bodies")))((("copy_from attribute")))an attribute that can be used only in link:http://cf-learn.info/ref/files[++files:++] promises, and indicates from where and how a file will be copied. It is an extremely flexible attribute, since it allows us to request local or remote file copies, how the files will be compared, whether the file will be encrypted in transit, and many other parameters. For example, the following two bodies are from CFEngine’s standard library:
+
--
[source,cf3]
----
include::{sourcedir}/ch03_12.cf[]
----

Both handle copying files from a remote server, and take both a server address and a source file as arguments. The first one specifies that the connection will be encrypted (using an internal CFEngine mechanism), that the files will be verified after copying them, and that files will be compared by computing a cryptographic hash of their contents. The second one is simpler, indicating no need for encryption or verification, and the comparison will be made using simply the time of last modification (++mtime++) of both files. The former, more expensive verification mechanism allows us to reliably detect changes in the files in cases when their modification date might not be a reliable indicator. In both cases, the comparison mechanism allows CFEngine to skip the expensive copy operation if the files already match.
--

* link:http://cf-learn.info/ref/depth_search[++depth_search++] is ((("bodies", "depth_search type")))((("depth_search bodies")))((("depth_search attribute")))another attribute of link:http://cf-learn.info/ref/files[++files:++] promises that allows us to control recursive operations. It specifies how deep to traverse, which directories to skip, and other parameters. For example:
+
--
[source,cf3]
----
include::{sourcedir}/ch03_13.cf[]
----

This definition specifies that only directories up to ++$(d)++ levels deep will be traversed (the special string ++"inf"++ can be used to specify infinite recursion), and allows the caller to specify a list of directories to exclude.

Putting((("copy_from attribute"))) link:http://cf-learn.info/ref/copy_from[++copy_from++] and link:http://cf-learn.info/ref/depth_search[++depth_search++] together, we can already create a functional file-copy promise:

[source,cf3]
----
include::{sourcedir}/ch03_14.cf[]
----

Here we will be copying all files from the directory __/var/cfengine/masterfiles/inputs__ on server 10.1.1.1 onto the local ++/var/cfengine/inputs++ directory (++$(sys.workdir)++ is ((("$(sys.workdir) variable")))an internal variable that CFEngine defines to be its working directory, normally ++/var/cfengine++). A recursive copy of infinite depth will be done, but all directories starting with +++_+++ will be ignored (the patterns provided have to be regular expressions and not shell metacharacter expressions, hence the `_.*` instead of just `_*`). Note that it is not possible to use link:http://cf-learn.info/ref/depth_search[++depth_search++] in conjunction with ++edit_line++. For editing files, the precise file to be edited needs to be specified.
--

* link:http://cf-learn.info/ref/edit_defaults[++edit_defaults++] is((("bodies", "edit_defaults type")))((("edit_defaults bodies")))((("edit_defaults attribute"))) an attribute of link:http://cf-learn.info/ref/files[++files:++] promises that controls parameters of the file-editing process. You can specify whether backups should be made of the original file, the maximum size of a reasonable file for editing, and whether the file should be emptied and recreated every time. In the following example, timestamped copies of the file will be kept every time the file is changed:
+
[source,cf3]
----
include::{sourcedir}/ch03_15.cf[]
----


* link:http://cf-learn.info/ref/edit_field[++edit_field++] is ((("bodies", "edit_field type")))((("edit_field bodies")))((("edit_field attribute")))an attribute of link:http://cf-learn.info/ref/field_edits[++field_edits:++] promises that performs field-based editing in a file (it must be specified as an attribute in a promise of type link:http://cf-learn.info/ref/field_edits[++field_edits:++], which in turn is allowable only inside link:http://cf-learn.info/ref/edit_line[++edit_line++] bundles). It specifies what characters to use as delimiters and which actions will be taken on which fields. For example, the following definition from the Standard Library performs generic field-editing operations using user-provided information:
+
--
[source,cf3]
----
include::{sourcedir}/ch03_16.cf[]
----

The((("select_field attribute")))((("field_separator attribute"))) ++split++ argument specifies a regular expression to use as separator (thus it gets assigned to the ++field_separator++ attribute), ++col++ indicates the column on which to operate and gets assigned to ++select_field++ (by default CFEngine starts counting from one, although this behavior can be changed using the ++start_fields_from_zero++ attribute in the link:http://cf-learn.info/ref/edit_field[++edit_field++] body), ++newval++ ((("value_separator attribute")))((("field_value attribute")))indicates the value to insert or delete from that field (it gets used for ++field_value++, each field can contain multiple values separated by ++value_separator++, a comma in this case), and ++method++ indicates which operation to perform (++set++, link:http://cf-learn.info/ref/delete[++delete++], ++append++, ++prepend++, etc.).

The((("bodies", "col() body")))((("col() body")))((("set_user_field() bundle"))) ++col()++ body definition can be used, for example, to edit colon-separated files, such as __/etc/passwd__ in Unix systems (this ++set_user_field()++ bundle is also defined in the Standard Library):

[source,cf3]
----
include::{sourcedir}/ch03_17.cf[]
----

This((("promises", "field_edits: type")))((("field_edits: promises")))
bundle takes three arguments: the user to edit (`user`), the field
number to edit (`field`), and the value to set in that field
(`val`). In
link:http://cf-learn.info/ref/field_edits[++field_edits:++] promises,
the promiser is interpreted as a regular expression that is matched
against all the lines in the file, to select which lines to edit. In
this case, the value of the ++$(user)++ parameter is used to select
the line that starts with that string, followed by a colon and any
other text (++"$(user):.*"++ —the pattern is automatically anchored by
CFEngine to the beginning and end of the line, so there is no need for
the ++^++ character to specify that the pattern must start at the
beginning of the line). Once((("edit_field attribute"))) a line is
selected, the link:http://cf-learn.info/ref/edit_field[++edit_field++]
attribute uses ++col()++ to perform the actual field-change operation,
The separator is specified as a colon, the field number and the new
value are passed directly from the arguments ++$(field)++ and
++$(val)++, and the operation to perform is ++"set"++, which tells
CFEngine to replace the old value of the field with the new one.

To ((("set_user_field() bundle")))put this in context, note that ++set_user_field()++ is an link:http://cf-learn.info/ref/edit_line[++edit_line++] bundle, which means it has to be used as the argument to the link:http://cf-learn.info/ref/edit_line[++edit_line++] attribute of a link:http://cf-learn.info/ref/files[++files:++] promise. For example:

[source,cf3]
----
include::{sourcedir}/ch03_18.cf[]
----
--

Many other body attributes are allowed in CFEngine for different promise types. I have shown here some of the most common ones, but you can find the full listing and details in the link:http://cf-learn.info/ref/promise-types-and-attributes[CFEngine Reference documentation].

[[I_sidebar3_d1e6049]]
.Bundles and Bodies Summary
****
The ((("bodies", "compared to bundles")))((("bundles", "compared to bodies")))distinction between bundles and bodies can be confusing at first. Remembering these points may help:


* Bodies are named groups of __attributes__, whereas bundles are collections of __promises__. Promises are the units that actually __do something__ in CFEngine (for example, run a command or add a line to a file), whereas attributes specify characteristics of how things are done (for example, whether to run the command in a shell, or where in the file to add the line).


* The value of an attribute can be a basic data type (string, integer, list, etc.), it can be the name of a body, or it can be the name of a bundle.


* The type of an attribute’s value is fixed, and determined by the attribute itself (for example, the value of the link:http://cf-learn.info/ref/depth_search[++depth_search++] attribute in a link:http://cf-learn.info/ref/files[++files:++] promise is always a body, and the value of an link:http://cf-learn.info/ref/edit_line[++edit_line++] attribute is always a bundle).


* For ((("bundles", "attributes corresponding to")))((("bodies", "attributes corresponding to")))((("attributes", "bodies corresponding to")))((("attributes", "bundles corresponding to")))bodies and bundles, their type is always the name of the attribute to which they correspond. For example, bodies to be used with the link:http://cf-learn.info/ref/depth_search[++depth_search++] attribute are always declared as “++body depth_search xyz++”, where ++xyz++ is an arbitrary name of your choosing. The same goes for bundles: bundles to be used with the link:http://cf-learn.info/ref/edit_line[++edit_line++] attribute are always declared as “++bundle edit_line xyz++".
 
There are only three types of “top level” bundles that are not used as arguments to attributes: link:http://cf-learn.info/ref/Bundles-for-agent[++agent++], link:http://cf-learn.info/ref/Bundles-for-server[++server++] and link:http://cf-learn.info/ref/Bundles-for-monitor[++monitor++].


* The promise types (sections) that can appear in a bundle are determined by the bundle type. For example, link:http://cf-learn.info/ref/commands[++commands:++] promises can only appear in bundles of (((range="endofrange", startref="ch3-bodies")))type link:http://cf-learn.info/ref/agent[++agent++].


****


[[namespaces]]
===== Namespaces

By ((("namespaces", id="ch3-namespace", range="startofrange")))default, all bodies, bundles, and classes in CFEngine exist in a common namespace. This makes it easy to call bundles and bodies from anywhere in the policy. However, as a policy grows in size to handle a large or complex infrastructure, and particularly if multiple people are in charge of writing policies, the possibility for naming conflicts increases—for example, it becomes entirely possible that a bundle named ++restart_service++ will be defined in two different files that correspond to different services.

To ((("body file control declaration")))avoid this problem, files can be assigned to link:http://cf-learn.info/ref/name-spaces[__namespaces__]. Bundles, bodies, and global classes with the same name can coexist, as long as they are in separate namespaces. To declare a namespace for the current file, you use a link:http://cf-learn.info/ref/file-control[++body file control++] declaration, like this:


[source,cf3]
----
body file control
{
        namespace => "name1"; 
}
----

If no namespace declaration is found, the ++default++ namespace is used. Note that the namespace declaration is placement-sensitive: it affects everything on the file after its appearance, and it can appear multiple times in a single file. This means that you can in principle declare bundles and bodies belonging to different namespaces in the same file. In practice, I would advise against this practice to avoid confusion, and recommend limiting each file to a single namespace, if any, by placing the link:http://cf-learn.info/ref/file-control[++body file control++] declaration at the top.

When you call a bundle or a body, CFEngine will look for it __only in the current namespace__ (whether it’s ++default++ or a declared one). To (((": (colon)", "following namespace reference")))((("colon (:)", "following namespace reference")))access things in a different namespace, you need to prepend their names with the namespace, separated by a colon. For example:


[source,cf3]
----
  methods:
      "any" usebundle => namespace:bundle("arg");

  files:
      "/tmp/file"
        create => true,
        perms => namespace:myperms;
----

Note((("scope", "of classes")))((("classes", "scope of")))((("global classes"))) that namespacing also affects global classes: they will be global only within the namespace in which they are declared. Global classes from other namespaces can also be used by prefixing them with the namespace, separated by a colon.


[WARNING]
====
Bundles and bodies in the CFEngine Standard Library are declared in the default namespace. To call them from a namespaced file, you need to explicitly prefix them with ++"default:"++.

====

We will not use namespaces in the examples in this book, to keep things simple. However, namespacing is a powerful mechanism that will help you grow your policies with a minimum of naming conflicts, so I encourage you to use them whenever(((range="endofrange", startref="ch3-namespace"))) appropriate.

[[normal-ordering]]
==== Normal Ordering

CFEngine((("CFEngine", "normal ordering used by", id="ch3-no", range="startofrange")))((("normal ordering", id="ch3-no2", range="startofrange")))((("order of evaluation", id="ch3-no3", range="startofrange"))) does not have any flow control statements, at least not in the sense with which you may be familiar from imperative programming languages (the concept of implicit flow control may be familiar to you if you have done any declarative programming before, for example in Prolog). A lot of the behavior of CFEngine is hard-coded, and this includes the order in which things are evaluated. This is called __normal ordering__, and is determined based on what makes sense for different types of bundles and promises. For example, it makes no sense to first create a file and then delete it, while it makes sense to first delete it and then create it again. Normal ordering can, if needed, be overriden by defining classes after an operation completes, and then defining other operations based on that class (for details, see <<controlling-promise-execution-order>>).

Bundles((("global classes")))((("scope", "of variables")))((("scope", "of classes")))((("variables", "scope of")))((("classes", "scope of")))((("common bundles")))((("bundles", "common type"))) of type link:http://cf-learn.info/ref/common[++common++] are a good place to define variables and classes that will be accessible to all other bundles in the policy. All classes in common bundles are global, and all variables in them are accessible from other bundles by prefixing them with the bundle name, as in ++$(bundle.variable)++.


[TIP]
====
CFEngine has mechanisms to detect variable/class dependencies and a best-effort algorithm to make sure all necessary values are available before an expression or promise is evaluated. You can help it ensure consistency and convergence by including bundles of type link:http://cf-learn.info/ref/common[++common++] in the link:http://cf-learn.info/ref/bundlesequence[++bundlesequence++] declaration, even though this is not strictly needed.

====

For((("policies", "three passes over")))((("bundles", "agent type")))((("agent bundles"))) link:http://cf-learn.info/ref/agent[++agent++] bundles, CFEngine will execute them up to three times in an attempt to achieve a convergent state. In each iteration, the sections in the bundle will be executed in the following order:


. link:http://cf-learn.info/ref/vars[ ++vars++ ]

. link:http://cf-learn.info/ref/classes[ ++classes++ ]

. link:http://cf-learn.info/ref/interfaces[ ++interfaces++ ]

. link:http://cf-learn.info/ref/files[ ++files++ ].

In turn, within link:http://cf-learn.info/ref/edit_line[++edit_line++] bundles, the following order will be kept:
[arabic]
.. link:http://cf-learn.info/ref/vars[ ++vars++ ]
.. link:http://cf-learn.info/ref/classes[ ++classes++ ]
.. link:http://cf-learn.info/ref/delete_lines[ ++delete_lines++ ]
.. link:http://cf-learn.info/ref/field_edits[ ++field_edits++ ]
.. link:http://cf-learn.info/ref/insert_lines[ ++insert_lines++ ]
.. link:http://cf-learn.info/ref/replace_patterns[ ++replace_patterns++ ]
.. link:http://cf-learn.info/ref/reports[ ++reports++ ]

. link:http://cf-learn.info/ref/packages[ ++packages++ ]

. link:http://cf-learn.info/ref/guest_environments[++guest_environments++]

. link:http://cf-learn.info/ref/methods[ ++methods++ ]

. link:http://cf-learn.info/ref/processes[ ++processes++ ]

. link:http://cf-learn.info/ref/services[ ++services++ ]

. link:http://cf-learn.info/ref/commands[ ++commands++ ]

. link:http://cf-learn.info/ref/storage[ ++storage++ ]

. link:http://cf-learn.info/ref/databases[++databases++]

. link:http://cf-learn.info/ref/reports[ ++reports++ ]

Within each section, promises will be executed in the order in which they appear in the policy. Multiple executions of each bundle mean that you can, for example, define a variable, then define a class based on that variable, and then define other variables depending on that class. The three iterations may not be executed in all cases - if there are no promises repaired during an iteration, then CFEngine assumes the bundle has converged, and stops further iterations.

Within((("bundles", "server type")))((("server bundles"))) link:http://cf-learn.info/ref/bundles-for-server[++server++] bundles, the normal ordering is as follows:


. link:http://cf-learn.info/ref/vars[ ++vars++ ]


. link:http://cf-learn.info/ref/classes[ ++classes++ ]


. link:http://cf-learn.info/ref/access[ ++access++ ]


. link:http://cf-learn.info/ref/roles[ ++roles++ ]


[NOTE]
====
Although syntactically correct, link:http://cf-learn.info/ref/reports-in-common-promises[++reports:++] promises that appear inside a link:http://cf-learn.info/ref/bundles-for-server[++server++] bundle are not evaluated.

====

Within((("bundles", "monitor type")))((("monitor bundles"))) link:http://cf-learn.info/ref/monitor[++monitor++] bundles, the normal ordering is as follows (sections marked with * are only available in CFEngine Enterprise):


. link:http://cf-learn.info/ref/vars[ ++vars++ ]


. link:http://cf-learn.info/ref/classes[ ++classes++ ]


. link:http://cf-learn.info/ref/measurements[++measurements++] *


. link:http://cf-learn.info/ref/reports[ ++reports++ ]

Normal ordering provides a fairly rigid structure to the execution of CFEngine policies. It is common when you first start writing CFEngine policies, particularly if you are familiar with imperative programming, to try to “fight” the normal ordering to fit what you want to do. When you encounter a case in which you are positive that normal ordering needs to be changed, I encourage you to back up and rethink at a higher level the task you want to accomplish. Most of the time, you will find that structuring the task in some other way will make the need to reorder operations go away, and will in fact make more sense with the way CFEngine(((range="endofrange", startref="ch3-no3")))(((range="endofrange", startref="ch3-no2")))(((range="endofrange", startref="ch3-no"))) “thinks.”

[[looping-in-cfengine]]
==== Looping in CFEngine

One((("implicit looping", id="ch3-loop", range="startofrange")))((("looping", id="ch3-loop2", range="startofrange"))) of the most evident examples of “thinking in CFEngine” is the concept of implicit looping. It is one of the most basic behaviors, one of the most confusing to a CFEngine beginner, and one of the most powerful once you harness it.

First, let((("lists", "looping with", id="ch3-loop3", range="startofrange"))) us define it: in CFEngine 3, if you refer to a list variable (normally called ++@(var)++) as a scalar (++$(var)++), CFEngine interprets it to mean “iterate over all the values in the list.”

Let’s try it. Type in the following policy:


[source,cf3]
----
include::{sourcedir}/ch03_19.cf[]
----

Now run it:

[source,console]
----
# cf-agent --no-lock --inform -f ./looping1.cf
2013-10-14T05:35:18+0000   notice: /test: R: red
2013-10-14T05:35:18+0000   notice: /test: R: green
2013-10-14T05:35:18+0000   notice: /test: R: blue
----

The lines that start with ++"R: "++ indicate messages produced by the link:http://cf-learn.info/ref/reports[++reports:++] promises in the policy. You can see that the single promise in the link:http://cf-learn.info/ref/reports[++reports:++] section has been repeated for every value in the list, therefore printing all the values.

You can also try nested looping:

[source,cf3]
----
bundle agent test
{
  vars:
      "colors" slist => { "red", "green", "blue" };
      "tone"   slist => { "dark", "light" };
  reports:
    cfengine_3::
      "$(tone) $(colors)";
}
----

This returns the following:

[source,console]
----
# cf-agent -K -f ./looping2.cf
2013-10-14T05:35:49+0000   notice: /test: R: dark red
2013-10-14T05:35:49+0000   notice: /test: R: light red
2013-10-14T05:35:49+0000   notice: /test: R: dark green
2013-10-14T05:35:49+0000   notice: /test: R: light green
2013-10-14T05:35:49+0000   notice: /test: R: dark blue
2013-10-14T05:35:49+0000   notice: /test: R: light blue
----

Simple enough, isn’t it? In this explicit example, the behavior is clear. The real power of implicit looping comes when you realize that it can be used in __any__ type of promise, and that it means the __whole promise__ will be executed as many times as there are items in the list. Also, the looping variable can be used anywhere—in defining variables or classes, in executing commands, or in making decisions with classes.

Let’s look at a real example in which implicit looping saved the day (this was, incidentally, the time when this really “clicked” in my head as I was starting with CFEngine 3). I needed to determine which network interface in a system was configured in a certain network segment, to apply some configuration commands.

CFEngine has a built-in array variable called ++sys.ipv4++ that contains the IP addresses of all the network interfaces in the system, indexed by interface name. My first thought was that I needed a function that gave me all the values stored in this array, so I could compare them against my desired IP address range and find the one I needed.

To ((("getvalues() function")))((("getindices() function")))my surprise, I realized that CFEngine has a link:http://cf-learn.info/ref/getindices[++getindices()++] function, but no equivalent link:http://cf-learn.info/ref/getvalues[++getvalues()++] function (actually this function was added as of version 3.1.5, but wasn’t available when I came up with this solution, and in any case this is much more elegant). After turning the problem over a lot in my head, I came to the realization that the link:http://cf-learn.info/ref/getvalues[++getvalues()++] function is not needed in this case. Here is the code I came up with:

[source,cf3]
----
include::{sourcedir}/looping3.cf[]
----

Let us look at this in detail.

<1> First, we get a list (using
    http://cf-learn.info/ref/getindices[getindices()] of all the
    network interfaces in the system, and store it in the nics
    variable. We also assign into ipregex the regular expression for
    the IP address range I want to match (in this case, 192.168.1.*).

<2> Then we use this list, referenced as a scalar, in the
    http://cf-learn.info/ref/classes[classes:] promise, to define a
    number of classes named after each of the interfaces, by using
    $(nics) in the class name itself. The definition of the class
    depends on whether the IP address of that network interface
    ($(nics) is used again in the call to the
    http://cf-learn.info/ref/regcmp[regcmp()] method) matches the
    regular expression of the IP address I want to find. The result is
    that, for each NIC on the system, the corresponding class is
    defined if its IP address matches, and undefined if it does not.

<3> Finally, we print all the interfaces by using $(nics) in a report
    message, and we also print only the matching ones by conditioning
    the second message using the ++ifvarclass => "ismatch_$(nics)"++
    attribute. The(((ifvarclass attribute))) reference to $(nics) in
    the http://cf-learn.info/ref/ifvarclass[ifvarclass] attribute is
    also expanded to each value in turn, so the second message is
    printed only for those NICs whose corresponding class is defined.

So you see, we do not need the ++getvalues()++ function after all. In
this example I used the defined classes to print messages, but in my
real example I used them to append the appropriate configuration
statements to a file—but only for those interfaces that matched the IP
range I wanted.

I encourage you to look at that example again, and make sure you
understand it. There are no looping constructs anywhere—in fact, they
do not exist in the CFEngine syntax at all. It may take a while
getting used to this. Whenever you are constructing a policy and you
think “I definitely need a ++while++ loop to do this,”
take a step back and see whether you can recast the problem using
implicit looping. The definition of classes based on a condition using
implicit looping is a powerful technique, and you will see it used in
many of the examples in this book.


[TIP]
====
Prior to CFEngine 3.3.0, looping was allowed only for local lists (those declared in the current bundle). Starting with 3.3.0 this limitation was removed, and you can now loop over lists from any bundle, provided that you properly qualifiy its name with the bundle name where it is (((range="endofrange", startref="ch3-loop3")))(((range="endofrange", startref="ch3-loop2")))(((range="endofrange", startref="ch3-loop")))declared (++$(bundle.var)++).

====

[[thinking-in-cfengine]]
==== Thinking in CFEngine

As we have seen, CFEngine imposes a rigid structure on many aspects of its operation. Two prime examples are normal ordering and implicit looping, which help get rid of the need for explicit control flow statements. For the most part, you do not tell CFEngine how to do things. Rather, you tell it __what you want to achieve__ and write out the low-level building blocks of how to achieve certain promises, and CFEngine will put them together for you to bring the system to the desired state.

If you are like me, you have been programming for some time before you encountered CFEngine, and your brain is wired to think about problems and tasks in a certain way. This will almost inevitably cause a clash when you have to “let go” of the control and lend it over to CFEngine.

I have personally found that what works for me is to “step back” from the details of the task at hand, and think at a higher level: “what am I trying to achieve?” Often this gives a different perspective on why you are doing certain things, and how you are trying to achieve them. My main advice is to keep practicing, and to use the community resources available to study examples and to get feedback on your promises from more experienced users.

[[clients-and-servers-2]]
=== Clients and Servers

One((("policy hub", "configuration of", id="ch3-config3", range="startofrange")))((("clients", "configuration of", id="ch3-config2", range="startofrange")))((("configuration of hubs and clients", id="ch3-config", range="startofrange")))((("CFEngine", "configuration of hubs and clients", id="ch3-config4", range="startofrange"))) of CFEngine’s key strengths is autonomy. A machine in which CFEngine is installed and configured does not need a network connection to operate, and as long as its policies are well defined, it will continue to obey those policies and maintain the system as configured. For instance, a laptop that is sometimes connected to the company network, but is also often away, will continue to benefit from CFEngine running on it.

However, the true power of CFEngine lies in its ability to manage thousands of machines with very little effort, and for this you need to distribute the corresponding policies to all those hosts. Fortunately, CFEngine makes it very easy to set up a client-server environment in which one or more hosts act as policy hubs, distributing policies and data to others. As we saw in <<bootstrapping-cfengine>>, all((("cf-agent command", "--bootstrap option")))((("policy hub", "bootstrapping"))) it requires is a single command to configure CFEngine and tell it which machine to use as its policy hub:

[source,console]
----
# cf-agent --bootstrap x.y.z.w
----


[WARNING]
====
Prior to CFEngine 3.5.0 the bootstrapping options were different. This is the command you have to run for older versions:

[source,console]
----
# cf-agent --bootstrap --policy-server x.y.z.w
----

====

This command works on both the policy hub itself and its clients. In the hub, link:http://cf-learn.info/ref/cf-agent[++cf-agent++] will recognize its own IP address and configure the host as a policy hub.

In its simplest form, and one perfectly suitable for all but the largest of organizations, you can have a single policy hub with multiple clients fetching policies and files from it, as shown in <<cfengine-simple-distributed>>.

[[cfengine-simple-distributed]]
.The simplest form of CFEngine distributed deployment, with a single policy hub and multiple clients
image::../figs/web/lcfe_0302.png[]

In larger and more complex environments, you can have a more complex structure. A CFEngine policy hub can itself be a client for some other hub, thus creating a hierarchy of CFEngine policy distribution points, as shown in <<cfengine-complex-distributed>>.

[[cfengine-complex-distributed]]
.More complex CFEngine distributed deployment, with multiple policy hubs in a hierarchy
image::../figs/web/lcfe_0303.png[]

The need for a hierarchical structure could be dictated by technical requirements (e.g., geographically disperse sites, low-bandwidth links between them, traffic blocking) or administrative needs (e.g., different teams in charge of different locations, needing to make their own customizations to the top-level inherited policies). CFEngine is flexible enough to accomodate any of them. Ideally, all the policy files should propagate from the top-level, where they are maintained in a master repository, but you could also have several disjoint trees in your organization.

CFEngine follows a strict pull-only philosophy: only the client can make requests to the server, asking for the information and files it needs. The server cannot push anything onto the clients. This convention makes it very simple to configure the network to allow communication between CFEngine clients and servers. Only ((("clients", "port used by")))((("port used by clients")))one port—TCP/5308—is necessary for the client to connect to the server. All communication, including file transfers, takes place through this port.


[NOTE]
====
The((("cf-runagent command"))) link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] command can be used on the server to contact the clients. In this case port, TCP/5308 also needs to be open from the server to the clients, and link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] needs to be running on the clients to process those connections. Note, however, that link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] does not allow the server to execute arbitrary commands on the clients. All that it does is instruct link:http://cf-learn.info/ref/cf-agent[++cf-agent++] on the client to “wake up” and process its policies immediately, instead of waiting for the next scheduled run. We will see the details of this configuration in <<remote-execution-cfrunagent>>.

====

The decision to only allow the clients to pull from the server (and not the server to push things onto the clients) is also rooted in promise theory. An entity cannot make promises about anyone other than itself. Because of this, the operation of a distributed system cannot depend on one entity forcing others to do something. Entities may request information from others, but they may make promises only about their own behavior. __Voluntary cooperation__ ((("voluntary cooperation")))is one of CFEngine’s core principles.

On the other hand, CFEngine is designed with resilience and graceful degradation in mind. If a client becomes disconnected from the network, CFEngine continues managing it using the latest locally-stored version of the policies until it restores connectivity. This allows clients to continue working during network outages, network congestion, security incidents, or other circumstances that may prevent connectivity to the master policy (((range="endofrange", startref="ch3-config2")))hub.

[[cfengine-server-configuration]]
==== CFEngine Server Configuration

The((("control bodies", "server control")))((("bodies", "server control")))((("server control bodies")))((("cf-serverd process"))) CFEngine server functionality is provided by the link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] process. It is configured using a link:http://cf-learn.info/ref/control-server[++server control++] body block like in the following example, taken from the default configuration provided with CFEngine (this is part of the __/var/cfengine/inputs/controls/cf_serverd.cf__ file generated when you bootstrap CFEngine):


[source,cf3]
----
include::{sourcedir}/ch03_20.cf[]
----


[TIP]
====
The default policy files produced by CFEngine when you bootstrap a client are an excellent starting point and provide a lot of basic functionality. I advise you to go over them and try to get at least a general understanding of what they do. Most of the parts you may need to customize are in __def.cf__, __promises.cf__ and some of the files under __controls/__, as needed.

====

This body defines the set of machines from which connections will be allowed ((("allowconnects attribute")))link:http://cf-learn.info/ref/allowconnects[allowconnects]), those that will be allowed to connect multiple times simultaneously ((("allowallconnects attribute")))link:http://cf-learn.info/ref/allowallconnects[allowallconnects]),footnote:[Normally each host is allowed only one connection at a time] those ((("maxconnections attribute")))((("skipverify attribute")))((("trustkeysfrom attribute")))whose public keys will be trusted if they have not been seen before ((("trustkeysfrom attribute")))link:http://cf-learn.info/ref/trustkeysfrom[trustkeysfrom]) and those whose DNS record will not be checked for consistency ((("skipverify attribute")))link:http://cf-learn.info/ref/skipverify[skipverify]). Also specified are the maximum number of simultaneous connections ((("maxconnections attribute")))link:http://cf-learn.info/ref/maxconnections[maxconnections]), the users that will be allowed to connect ((("allowusers attribute")))link:http://cf-learn.info/ref/allowusers[allowusers]), and whether machines with out-of-sync clocks will be blocked ((("denybadclocks attribute")))link:http://cf-learn.info/ref/denybadclocks[denybadclocks]).

Additionally, ((("bundles", "access_rules() bundle")))((("access_rules() bundle")))((("ACLs", "access_rules() bundle for")))per-directory and per-file ACLs can be defined in the ++access_rules()++ bundle, whose default version contains the following:


[source,cf3]
----
include::{sourcedir}/ch03_21.cf[]
----

This((("ACLs", "access: promises for")))((("promises", "access: type")))((("access: promises"))) bundle contains promises of type link:http://cf-learn.info/ref/access[++access:++], which define the ACLs to apply. In this case, directory ++$(def.dir_masterfiles)++ (which expands by default to __/var/cfengine/masterfiles__) will be accessible by all machines in the ++$(def.domain)++ domain, plus those defined explicitely in the ++@(def.acl)++ list.

Note ((("$(domain) variable")))((("@(acl) variable")))((("bundles", "def() bundle")))((("def() bundle")))((("ACLs", "variables for")))that most of these parameters include the ++@(def.acl)++ and ++$(def.domain)++ variables. These are references to the ++acl++ and ++domain++ variables defined in the ++def()++ bundle, which is defined in __/var/cfengine/inputs/def.cf__:


[source,cf3]
----
include::{sourcedir}/ch03_22.cf[]
----

You are expected to edit the ++def()++ bundle before putting CFEngine into production, in particular two values:


<1> The $(domain) variable must contain the domain name of your
     current environment. This is used in the code shown earlier to
     limit access to machines from this domain. It is also used in
     some other contexts in the default _promises.cf_ file.

<2> The @(acl) variable is a list containing all the IP addresses that
    should have access to the server. This promise uses the value of
    $(sys.policy_hub) (an pass:[<a data-type="indexterm" data-primary="$(sys.policy_hub) variable" data-primary-sortas="sys.policy_hub variable"> </a>]
    automatically-set variable that contains the IP address of the hub
    from which the host was bootstrapped) and determines its local
    class-B network (/16). The assumption is that the policy hub will
    in most cases be in the same network as the client. Of course,
    this range may well be too broad or too narrow according to your
    needs, so you must edit it pass:[<a data-type="indexterm" data-primary="" data-startref="ch3-config3"> </a><a data-type="indexterm" data-primary="" data-startref="ch3-config"> </a><a data-type="indexterm" data-primary="" data-startref="ch3-config4"> </a>]
    accordingly.


==== Updating Client Files from the Server

One((("clients", "updating files from server", id="ch3-update", range="startofrange")))((("policy hub", "updating client files from", id="ch3-update2", range="startofrange"))) of the main tasks of the policy hub is to distribute policy files, and any other necessary files, to its clients. This is a crucial operation, since it makes it possible to update files on the hub and have them propagate automatically to all the clients. To this effect, CFEngine provides ample capabilities for efficient and secure file transfer.

The ((("bundles", "cfe_internal_update() bundle")))((("cfe_internal_update() bundle")))default policy installed with CFEngine contains a bundle called ++cfe_internal_update()++ which is executed __on the clients__ (remember that the CFEngine policy hub cannot instruct the clients to do anything). It takes care of all these tasks automatically, but you may want to modify it according to your needs. It((("update.cf file"))) is contained in the file __/var/cfengine/inputs/update.cf__, and in a nutshell these are the tasks it performs:


* Check whether the host key files exist (under __/var/cfengine/ppkeys/__), and run ++cf-key++ to create them if they are not present.


* Start the ++cf-serverd++, ++cf-monitord++ and ++cf-execd++ processes if they are not running.


* Copy updated files from __/var/cfengine/masterfiles/__ on the policy hub to __/var/cfengine/inputs/__ on all machines (both the clients and the policy hub) to put them in production.


* Symlink CFEngine binaries from __/var/cfengine/bin/__ to __/usr/local/sbin/__ for easier access.


* Ensure all critical directories and files have the correct permissions.

For now we will look only at the file-copying operations, but I encourage you to read through the whole bundle to get an idea of what it does. These are the crucial parts:


[source,cf3]
----
include::{sourcedir}/ch03_23.cf[]
----


<1>   The $(inputs_dir) variable contains the directory where the local
  CFEngine installation expects to find its policy files. On Unix/Linux
  hosts this is normally __/var/cfengine/inputs__, but the location can
  vary in different platforms. For this reason, we are using the
  $(sys.workdir) ((("$(sys.workdir) variable",sortas="sys.workdir
  variable")))variable, which is automatically defined to be the base
  directory of the local CFEngine installation. We are also using the
  translatepath() function to translate the Unix-style path into the
  local style (for example, using backslashes instead of forward slashes
  on Windows).
<2>   The $(master_location) variable contains the directory on the policy
  hub where the "master files" are located, and from where they will be
  copied to the local host. The policy hub has to be a Unix-style host,
  so in this case we don't need to perform any path translation.
<3>   The((("promises","files: type")))((("files: promises"))) `files:`
  promise is the one that does the actual work. The promiser is the
  destination directory $(inputs_dir), to which the files will be copied
  according to the parameters specified by the promise attributes that
  follow.
<4>   The((("copy_from attribute"))) `copy_from` attribute indicates the
  source of the files. The value of this attribute is a body, defined in
  the same _update.cf_ file as follows: pass:[<pre data-type="programlisting" data-code-language="cf3">body copy_from u_rcp(from,server)
{
        source      => "$(from)";
        compare     => "digest";
        trustkey    => "true";
    !am_policy_hub&#58;&#58;
        servers => { "$(server)" };
}</pre>]
  This body receives as arguments the directory and the host from where
  the files should be copied. $(master_location) is the variable defined
  before, ((("$(sys.policy_hub) variable",sortas="sys.policy_hub
  variable")))and $(sys.policy_hub) is a special CFEngine variable that
  is set when the client is bootstrapped, as described in
  #bootstrapping-cfengine. Additionally, ((("trustkey
  attribute")))((("compare attribute")))it indicates that the files
  should be compared using a cryptographic digest (compare => "digest"),
  and that the client should trust the cryptographic keys presented by
  the server (http://cf-learn.info/ref/trustkey[`trustkey => "true"`]).
  The `servers` attribute is set only when the am_policy_hub class is
  not set, and am_policy_hub is a hard class set only on the policy hub,
  so the effect is that on the policy hub, the file copy operation will
  be done locally, from _/var/cfengine/masterfiles/_ to
  __/var/cfengine/inputs/__.
<5>   The((("depth_search attribute"))) `depth_search` attribute is used to
  indicate a recursive file copy operation of infinite depth. Its value
  is another body: pass:[<pre data-type="programlisting" data-code-language="cf3">
body depth_search u_recurse(d)
{
        depth => "$(d)";
        exclude_dirs => { "\.svn" };
}</pre>]
  The((("exclude_dirs attribute")))((("depth attribute"))) `depth`
  attribute is set to the passed argument (which can be a number, or the
  special value `"inf"` for infinite recursion). The `exclude_dirs`
  attribute is also used to skip version-control directories that may be
  present in the server (assuming that version control is done using
  Subversion).
<6>   The((("file_select attribute"))) `file_select` attribute is used to
  control which types of files are copied. This is another body: pass:[<pre data-type="programlisting" data-code-language="cf3">body file_select u_input_files
{
        leaf_name => { ".*.cf",".*.dat",".*.txt" };
        file_result => "leaf_name";
}</pre>]
  In((("file_result attribute")))((("leaf_name attribute"))) this case
  we are asking CFEngine to copy only files whose names end with `.cf`,
  `.dat` and `.txt`. There are many criteria that can be specified in a
  `file_select` body, and for this reason we need the `file_result`
  attribute to tell CFEngine on which criteria we want to match (in this
  case it is the only one available).
<7>   The `classes` attribute indicates that if any files are copied (which
  flags the promise as “repaired”), then the update_report class should
  be set. This class can be used in other parts of the policy to execute
  any actions necessary (for example, produce a report) when the files
  are updated. This is yet another body that sets the appropriate class:
  pass:[<pre data-type="programlisting" data-code-language="cf3">body classes u_if_repaired(x)
{
        promise_repaired => { "$(x)" };
}</pre>]

File-copy promises are extremely flexible and powerful. Policy and binary updates are automatically handled by the built-in CFEngine policies, but I encourage you to read the link:http://cf-learn.info/ref/files-in-agent-promises[documentation for ++files:++ promises] to get a good idea of the wide range of tasks they can perform.


[NOTE]
====
Why((("update.cf file"))) is this bundle in the __update.cf__ file instead of the __promises.cf__ file? The default CFEngine policy instructs ++cf-execd++ (this is defined in the ++body executor control++ in __/var/cfengine/inputs/controls/cf_execd.cf__) to always evaluate __update.cf__ before running __promises.cf__, to ensure that all files are properly updated. Additionally, if((("failsafe.cf file"))) there is any failure in policy evaluation, ++cf-agent++ automatically tries to load __failsafe.cf__, which performs many of the same update operations to try and bring CFEngine back into (((range="endofrange", startref="ch3-update2")))(((range="endofrange", startref="ch3-update")))operation.

====

[[remote-execution-cfrunagent]]
==== CFEngine Remote Execution Using cf-runagent

One((("cf-runagent command", id="ch3-remote", range="startofrange")))((("remote execution", id="ch3-remote2", range="startofrange")))((("CFEngine", "remote execution of", id="ch3-remote3", range="startofrange"))) of the basic premises of CFEngine is that clients operate autonomously. If there is a central coordination point, like the policy hub, it is up to the clients to connect to it and fetch policies or files. However, in practice, the server (or some other machine) sometimes needs to “ping” the clients and ask them to do something. This is where link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] comes in. It does not allow arbitrary actions to be executed, but simply asks the remote machine to run link:http://cf-learn.info/ref/cf-agent[++cf-agent++] and evaluate its policies. The remote host (in most cases it would be a CFEngine client) needs to have link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++] running and configured to listen for connections from link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++].

Allow me to emphasize this point: link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] does not allow the execution of arbitrary commands or arbitrary actions on a remote host. It simply instructs the host to run link:http://cf-learn.info/ref/cf-agent[++cf-agent++] and start evaluating its policies. This is useful when you don’t want to wait until the next regular execution of link:http://cf-learn.info/ref/cf-agent[++cf-agent++] (for example, critical policy or operating system updates).

The((("bodies", "runagent control", id="ch3-runa", range="startofrange")))((("control bodies", "runagent control", id="ch3-runa2", range="startofrange")))((("runagent control body", id="ch3-runa3", range="startofrange"))) behavior of the link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] command can be configured as part of the CFEngine policy in a link:http://cf-learn.info/ref/control-runagent[++runagent control++] body, which allows you to specify, among other things, a list of hosts that will be contacted by default when running the command. On the client side (the one to which the ++cf-runagent++ command will connect), the ++server control++ body specifies whether link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] connections will be allowed, and what they will be allowed to do. It can also specify a list of remote users that will be allowed to set custom classes when running link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++]. This allows more fine-grained control of the policy behavior.

link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] connections are handled by link:http://cf-learn.info/ref/cf-serverd[++cf-serverd++], so if you need this functionality you will also need to open port TCP/5308 traffic from the server to the clients.

Because((("cfruncommand attribute"))) of its potential security implications, the ++cf-runagent++ functionality comes disabled in the CFEngine default policy. To enable it, you need to uncomment the ++cfruncommand++ attribute in the server control body, shown in <<cfengine-server-configuration>>:


[source,cf3]
----
cfruncommand          => "$(sys.cf_agent)";
----

This instructs ++cf-serverd++ to listen for connections from ++cf-runagent++, and to execute ++cf-agent++ in response to them (remember that this is all that ++cf-runagent++ allows you to do: wake up ++cf-agent++). We still need to instruct cf-serverd to allow access to the ++cf-agent++ binary (its ((("$(sys.cf_agent) variable")))path is stored in the special variable link:http://cf-learn.info/ref/cf_agent[++$(sys.cf_agent)++], normally __/var/cfengine/bin/cf-agent__) from the policy hub. We need to do this in the ++access_rules()++ bundle, stored in __/var/cfengine/inputs/controls/cf_serverd.cf__:


[source,cf3]
----
bundle server access_rules()
{
 access:
  any::
...
  "$(sys.cf_agent)"
    handle => "grant_access_policy_agent",
    comment => "Grant access to the agent (for cf-runagent)",
    admit => { "$(sys.policy_hub)" };
}
----

In this case, we are telling ++cf-serverd++ to allow access to the link:http://cf-learn.info/ref/cf-agent[++cf-agent++] binary only to the policy hub, as defined by the special variable link:http://cf-learn.info/ref/policy_hub[++$(sys.policy_hub)++].

Finally, we need to tell the policy hub which hosts to contact by default when link:http://cf-learn.info/ref/cf-runagent[++cf-runagent++] is executed. We need to do this explicitly in the link:http://cf-learn.info/ref/control-runagent[++runagent control++] body:


[source,cf3]
----
body runagent control
{
      # A list of hosts to contact when using cf-runagent

    any::

        hosts => { "127.0.0.1" };

      # , "myhost.example.com:5308", ...

}
----

Note that defining this list is not strictly necessary, as the list of hosts can be specified in the command line when running ++cf-runagent++, using (((range="endofrange", startref="ch3-runa3")))(((range="endofrange", startref="ch3-runa2")))(((range="endofrange", startref="ch3-runa")))(((range="endofrange", startref="ch3-remote3")))(((range="endofrange", startref="ch3-remote2")))(((range="endofrange", startref="ch3-remote")))the ++--hail++ option.

[[cfengine-information-resources]]
=== CFEngine Information Resources

CFEngine((("online resources", id="ch3-res", range="startofrange")))((("documentation for CFEngine", id="ch3-res2", range="startofrange")))((("CFEngine", "documentation for", id="ch3-res3", range="startofrange"))) has been around for a long time, and it has developed a solid body of documentation and information. In addition to community support, the company that was formed to provide commercial support for CFEngine, CFEngine AS, provides extensive documentation and information, most of it free of charge.

One word of caution: Some of the information you find online may still be geared towards CFEngine 2. While you can apply many of the basic ideas, be aware that the syntax of CFEngine 3 is completely different and incompatible with the previous version.

Let’s look at some of the information resources available for CFEngine 3.

[[manuals-and-official-guides]]
==== Manuals and Official Guides

Most of the documentation made available by CFEngine AS can be found at the link:https://cfengine.com/docs[CFEngine Documentation web page]. The core documentation includes the following:


* link:https://cfengine.com/docs/3.5/reference.html[__Reference guides__]: the most complete and authoritative reference for CFEngine concepts, installation, syntax, and examples.


* link:https://cfengine.com/docs/3.5/manuals.html[Manuals]: documents that describe different aspects of CFEngine, including its design, architecture and components, basic language concepts and more.

Apart from the core documents, you will find here a growing collection of link:http://cfengine.com/cfengine-special-topic-guides[Special Topics Guides], a series of shorter documents that focus on specific advanced aspects of working with CFEngine. You can find documentation about best practices for different topics, such as team collaboration, integrating CFEngine into change management practices or specific frameworks such as the ITIL standard, reporting capabilities, knowledge management, etc.

[[cfengine_stdlib]]
==== CFEngine Standard Library

The((("Standard Library", see="CFEngine Standard Library")))((("CFEngine Standard Library", id="ch3-std2", range="startofrange"))) CFEngine Standard Library contains implementations of a large number of commonly-used promise bundles and bodies. It includes bundles for tasks such as editing files in common formats, interfacing with common package and service managers, editing text files, and copying files. The standard library allows you to focus on the task at hand without having to worry about the details, and also serves as a fantastic source of examples, based on which you can extend or define your own bundles and bodies for CFEngine configuration. This library is constantly evolving, and users are encouraged to submit changes and additions to it. The CFEngine standard library is hosted in the link:https://github.com/cfengine/masterfiles[++cfengine/masterfiles++] repository on GitHub, but is included with the CFEngine distribution.


[NOTE]
====
The CFEngine Standard Library used to be known as the Community Open Promise Body Library (COPBL). This name is no longer being used, but you may still see some references to it.

====

The((("CFEngine", "version numbers of", id="ch3-vn", range="startofrange"))) Standard Library underwent some recent reorganization, so depending on which version of CFEngine you are using, you need to use different methods to load it:


* Up ((("cfengine_stdlib.cf file")))((("CFEngine Standard Library", "cfengine_stdlib.cf file")))until CFEngine 3.4.x, the standard library was contained in the single file __cfengine_stdlib.cf__. To use it, you must include it in your policy, in the ++common control++ body:

[source,cf3]
----
body common control
{
    inputs => { "cfengine_stdlib.cf" };
}
----


* In((("inputs attribute"))) CFEngine 3.5.0, the __cfengine_stdlib.cf__ file was moved to the __libraries/__ directory, so you need to update its path in your link:http://cf-learn.info/ref/inputs[++inputs++] attribute:

[source,cf3]
----
body common control
{
    inputs => { "libraries/cfengine_stdlib.cf" };
}
----


* In CFEngine 3.5.1 and later, the __cfengine_stdlib.cf__ file was split into multiple files by promise type, to cope with the increasing size and complexity of the standard library. Starting in this version, the parts of the library are stored under __lib/MAJOR.MINOR/__. For ((("files.cf file")))((("CFEngine Standard Library", "files.cf file")))example, in CFEngine 3.5.2, all bodies and bundles related to link:http://cf-learn.info/ref/files[++files:++] promises are stored in __lib/3.5/files.cf__. You need to load the parts that you are going to use in your policy, for example:

[source,cf3]
----
body common control
{
    inputs => { "lib/3.5/common.cf",
                "lib/3.5/files.cf",
                "lib/3.5/commands.cf" };
}
----

Note that __libraries/cfengine_stdlib.cf__ is still included in newer CFEngine distributions, but that file only includes bodies and bundles that are compatible with CFEngine 3.5.0 or earlier. You need to use the files from the version-specific directories if you want to get bodies and bundles that use newer features of the language.

[TIP]
====
The((("promises.cf file"))) default __promises.cf__ file in all CFEngine distributions automatically loads the standard library using the correct method for the current version of CFEngine, so you only need to worry about how to load it (and which parts to load) for standalone policy files you write. In this book, for the examples that need it, we will sometimes see the __cfengine_stdlib.cf__ file, and others the specific files from the split library.
====

As of this CFEngine 3.5.2, the files that comprise the Standard Library (installed under __/var/cfengine/inputs/lib/3.5/__) are:

 bundles.cf:: 
    Contains((("bundles.cf file")))((("CFEngine Standard Library", "bundles.cf file"))) standalone agent bundles that perform common tasks, such as ++fileinfo()++ (extract file information using the ++filestat()++ function) and ++logrotate()++ (rotate log files by size).


commands.cf:: 
    Defines ((("commands.cf file")))((("CFEngine Standard Library", "commands.cf file")))a number of link:http://cf-learn.info/ref/contain[++contain++] bodies for use with link:http://cf-learn.info/ref/commands[++commands:++] promises.


common.cf:: 
    Defines ((("common.cf file")))((("CFEngine Standard Library", "common.cf file")))bodies that can be used with all promise types, such as link:http://cf-learn.info/ref/action[++action++] and link:http://cf-learn.info/ref/classes[++classes++] bodies.


databases.cf:: 
    Contains((("databases.cf file")))((("CFEngine Standard Library", "databases.cf file"))) ++database_server++ bodies to use with link:http://cf-learn.info/ref/databases[++databases:++] promises.


files.cf:: 
    Includes((("files.cf file")))((("CFEngine Standard Library", "files.cf file"))) all bundles and bodies that can be used with link:http://cf-learn.info/ref/files[++files:++] promises, including link:http://cf-learn.info/ref/edit_line[++edit_line++] bundles, ++edit_field ++bodies, link:http://cf-learn.info/ref/copy_from[++copy_from++] bodies, etc.


guest_environments.cf:: 
    Includes((("promises", "guest_environments: type")))((("guest_environments: promises")))((("guest_environments.cf file")))((("CFEngine Standard Library", "guest_environments.cf file"))) link:http://cf-learn.info/ref/environment_resources[++environment_resources++] bodies to use in defining virtual machines for link:http://cf-learn.info/ref/guest_environments[++guest_environments:++] promises.


monitor.cf:: 
    Includes((("monitor.cf file")))((("CFEngine Standard Library", "monitor.cf file"))) bodies that can be used with link:http://cf-learn.info/ref/measurements[++measurements:++] promises (only in CFEngine Enterprise), such as link:http://cf-learn.info/ref/match_value[++match_value++] bodies.


packages.cf:: 
    Includes((("packages.cf file")))((("CFEngine Standard Library", "packages.cf file"))) all link:http://cf-learn.info/ref/package_method[++package_method++] body definitions, to use with link:http://cf-learn.info/ref/packages[++packages:++] promises to interact with different package and software managers.


paths.cf:: 
    Contains((("paths.cf file")))((("CFEngine Standard Library", "paths.cf file"))) the ++paths++ common bundle, which defines the paths for many common system binaries in different operating systems. By using this bundle, you can make your policies system-independent by avoding hard-coded command paths. For example, instead of using this, which will break on systems where ping is installed on a different path:

[source,cf3]
----
include::{sourcedir}/ch03_24.cf[]
----

You can use this:

[source,cf3]
----
include::{sourcedir}/ch03_25.cf[]
----


processes.cf:: 
    Includes((("processes.cf file")))((("CFEngine Standard Library", "processes.cf file"))) link:http://cf-learn.info/ref/process_select[++process_select++] and link:http://cf-learn.info/ref/process_count[++process_count++] bodies for use with link:http://cf-learn.info/ref/processes[++processes:++] promises.


services.cf:: 
    Includes((("services.cf file")))((("CFEngine Standard Library", "services.cf file"))) the ++standard_services()++ bundle, which provides the built-in support for most common services in different operating systems, and implements the default behavior of link:http://cf-learn.info/ref/services[++services:++] promises.


storage.cf:: 
    Defines((("storage.cf file")))((("CFEngine Standard Library", "storage.cf file"))) link:http://cf-learn.info/ref/volume[++volume++] and link:http://cf-learn.info/ref/mount[++mount++] bodies to use with link:http://cf-learn.info/ref/storage[++storage:++] (((range="endofrange", startref="ch3-vn")))promises.


The standard library provides you with basic building blocks for implementing different tasks using CFEngine, but it provides no ready-made solutions for complex problems. This is the role of the CFEngine Solutions Guide and the CFEngine Design (((range="endofrange", startref="ch3-std2")))Center.

[[cfengine-solutions-guide]]
==== CFEngine Solutions Guide

The((("Solutions Guide for CFEngine")))((("CFEngine Solutions Guide"))) link:https://docs.cfengine.com/docs/archive.bak/cf-manuals/cf3-solutions.html[Solutions Guide] is a collection of modular bundles with examples that are more complex than the building blocks included in the standard library, often corresponding to full tasks such as user creation and maintenance, email server management, or web server configuration. Some of these examples can be used as-is, but they are more suitable as starting points on which you can base your own configurations, customized to your specific needs and situation.


[[community-forums]]
==== Community Forum and IRC channel

The((("IRC channel")))((("community forum")))((("forum"))) official CFEngine help forum can be found in Google Groups, at link:http://bit.ly/cf_forum_new[], and is a fantastic resource of information and help. Both CFEngine developers and advanced users participate actively in the forum, providing a friendly and fertile ground for newcomers to ask questions and learn about CFEngine, and for experienced users to exchange information, discuss advanced aspects, and provide feedback to the developers.

The official IRC channel is called ++#cfengine++ and hosted on link:http://freenode.net/[] (use your favorite IRC client to connect to it). It is a good place to ask questions and have informal discussions with CFEngine users, engineers and developers. I would advise you to post complex questions to the forum, and use IRC only for quick questions or conversations.

[[cfengine-bug-tracker]]
==== CFEngine Bug Tracker

The((("CFEngine", "bugs in, tracking")))((("bugs in CFEngine, tracking"))) official mechanism for reporting bugs or feature requests is the link:http://cfengine.com/dev/[CFEngine issue tracker].

[[other-community-provided-resources]]
==== Other Community Resources

CFEngine users have also developed and made available an incredible amount of useful resources. Here is the list of some of the most useful ones.


* Neil H. Watson’s link:http://watson-wilson.ca/blog/2011/03/08/cfengine-tutorial/[CFEngine 3 Tutorial] was((("Watson, Neil H. (author)", "CFEngine 3 Tutorial")))((("CFEngine 3 Tutorial (Watson)"))) one of the first tutorials available specifically for CFEngine 3, and provides a very useful, hands-on guide to CFEngine installation and setting up an initial scheme for experimenting. Neil also blogs at link:http://watson-wilson.ca[] about CFEngine, frequently providing useful tips and information.


* Jessica Greer’s link:https://github.com/jlgreer/yale_cfengine3/[Yale University’s CFEngine 3 library] shows((("Greer, Jessica (author)", "Yale University's CFEngine 3 Library")))((("Yale University's CFEngine 3 Library (Greer)"))) many real-world examples of bodies and bundles used to maintain Yale’s computers with CFEngine. This library is also available in the CFEngine Design Center.


* Aleksey Tsalolikhin’s link:http://verticalsysadmin.com/blog/guide-to-cfengine-3-body-of-knowledge/[Guide to CFEngine 3 Body of Knowledge] is((("Tsalolikhin, Aleksey (author)", "Guide to CFEngine 3 Body of Knowledge")))((("Guide to CFEngine 3 Body of Knowledge (Tsalolikhin)"))) a great collection of links to a lot of the information available about CFEngine 3, including many of the resources already mentioned. Aleksey is a prolific CFEngine expert and trainer.


* The link:https://cfengine.com/learn/[CFEngine Learning Center] page ((("CFEngine Learning Tools")))((("Learning Tools for CFEngine")))contains pointers to many of these documents, and many other resources that will help you understand and make better use of CFEngine.

[[recommended-reading-order]]
==== Recommended Reading Order

As a ((("CFEngine Reference")))((("Language Concepts for CFEngine")))((("CFEngine Language Concepts")))companion to this book, I would recommend reading and exploring the link:https://docs.cfengine.com/docs/3.10/reference-language-concepts.html[CFEngine Language Concepts page] from CFEngine AS, and to always have the link:https://docs.cfengine.com/docs/3.10/reference-all-types.html[CFEngine Reference pages] handy for the full details about the CFEngine policy language. All the examples in this book make heavy use of the standard library, and some of the more complex ones are extensions of the problems shown in the CFEngine solutions guide. I strongly recommend following and participating in the CFEngine forum, and contributing as you can to resources such as the CFEngine Design Center or through any other venue in which you are a regular (((range="endofrange", startref="ch3-res3")))(((range="endofrange", startref="ch3-res2")))(((range="endofrange", startref="ch3-res")))participant (forum, mailing lists, etc.).
